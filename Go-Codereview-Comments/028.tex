\section{Receiver Type}

メソッドのレシーバーをポインタにするか否かを選択することは常に難しいものです。特にGoを学び始めた頃には難しいでしょう。 疑わしい場合はポインタを受け取りますが、小さい構造体や、プリミティブな型の場合は、値を受け取るだけのほうが効率的な場合があります。 判断のためのガイドラインを下に示します。

\begin{itemize}
  \item レシーバが \texttt{map}、\texttt{func}、チャネル ならポインタを使うべきではありません。レシーバがスライスで、メソッドがスライスを作りなおさない場合は、ポインタを使うべきではありません。
  \item メソッドが値を変更する必要がある場合、レシーバはポインタでなければいけません。
  \item レシーバが \texttt{sync.Mutex} か、似たような同期するフィールドを持つ構造体なら、レシーバはポインタでなければいけません。
  \item レシーバが大きな構造体や配列なら、ポインタはとても効果的です。では大きいとはどれくらいなのでしょう？もし構造体の全ての値を引数に渡すと仮定してください。多すぎると感じたなら、それはポインタにしても良いくらいの大きさです。
  \item 関数が同時に実行されたりメソッドが呼び出された時に、レシーバの値を変更するでしょうか？値渡しではメソッドが実行されるときにレシーバのコピーを生成します。なのでメソッドの外ではレシーバへの変更が適用されません。変更がオリジナルのレシーバに適用される必要があるなら、レシーバはポインタです。
  \item レシーバが、値を変更されるかも知れない構造体、配列、スライス、その他の要素であった場合、レシーバをポインタにしたほうが、読み手にとってよりわかりやすいでしょう。
  \item レシーバが小さく、本来値型であったり(例えば \texttt{time.Time} のようなもの) 、変更するフィールドやポインタがない構造体や配列、あるいは \texttt{int} や \texttt{string} のようなシンプルな型の場合は、レシーバが値であるほうが良い場合があります。値のみのレシーバは生成されるゴミの量を減らすことができます。もし値がメソッドに渡されると、ヒープ領域にメモリを確保する代わりに、スタックメモリのコピーが走ります。(コンパイラはこのヒープメモリ確保を避けようとしますが、常には上手く行きません) プロファイラで確認する前にこの理由で値レシーバにするのは辞めましょう。
  \item これらの理由に当てはまらず、まだ迷っている場合はレシーバをポインタにしましょう。
\end{itemize}
