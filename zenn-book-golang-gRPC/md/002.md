
# RPCの具現化であるgRPC



さき(H.Saki)



2022.06.19に更新






[]{style="display:block;width:1px;height:2.7rem;flex-shrink:0"}



このチャプターの目次![](data:image/svg+xml;base64,PHN2ZyB2aWV3Ym94PSIwIDAgMjcgMjciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgY2xhc3M9IkNoYXB0ZXJUb2NfdG9nZ2xlSWNvbl9fNERfVlQiPjxwYXRoIGZpbGw9ImN1cnJlbnRDb2xvciIgZD0iTTEyLjc0IDIwLjUzbC05LjI2LTkuMThhLjc1Ljc1IDAgMDEwLTEuMDdsMS4yMy0xLjIzYS43NS43NSAwIDAxMS4wNyAwbDcuNDkgNy40MSA3LjQ5LTcuNDFhLjc0Ljc0IDAgMDExLjA2IDBsMS4yNCAxLjIzYS43Ny43NyAwIDAxMCAxLjA3bC05LjI2IDkuMThhLjc0Ljc0IDAgMDEtMS4wNiAweiI+PC9wYXRoPjwvc3ZnPg==){.ChapterToc_toggleIcon__4D_VT}



1.  [この章について](#%E3%81%93%E3%81%AE%E7%AB%A0%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)
2.  [RPC(Remote Procedure
    Call)とは](#rpc(remote-procedure-call)%E3%81%A8%E3%81%AF)
3.  [gPRCとは](#gprc%E3%81%A8%E3%81%AF)
    1.  [gRPCが用いる技術](#grpc%E3%81%8C%E7%94%A8%E3%81%84%E3%82%8B%E6%8A%80%E8%A1%93)






# この章について

この章では、まずgRPCの元となる考え方である*\*RPC(Remote Procedure
Call)\*\*について紹介します。
その後、RPCを実現するためにgRPCはどのような技術を裏でどう使っているのかについて説明していきます。

# RPC(Remote Procedure Call)とは

RPC(Remote Procedure
Call)とはどういう考え方なのかを説明する前に、まずは以下のプログラムをご覧ください。


``` language-go
package main

func main() {
    res := hello("hsaki")
    fmt.Println(res)
}

func hello(name string) string {
    return fmt.Sprintf("Hello, %s!", name)
}
```


`main`関数の中から`hello`関数に引数を渡して呼び出し、そこから戻り値を受け取って標準出力にprintしているプログラムです。
これの表現を変えると「`main`関数の中から`hello`という**Procedure**^[\[1\]](#fn-8529-1){#fnref-8529-1}^(手続き)を**Call**(呼び出し)している」というようにもいうことができます。

ここで例にあげたProcedure
Callは「`main`関数と呼び出しProcedureである`hello`関数が、同じローカル上にある」パターンです。
これに対して**Remote** Procedure
Callは、呼び出し元(=`main`関数)と呼び出されるProcedure(=`hello`関数)が別の場所・別のサーバー上にあるパターンのことを指しています。
つまり、「そのAPIが提供したいサービスをProcedureとしてサーバー上に実装して、それをAPIを使う側であるクライアントコードから直接呼び出すようにする」という発想が\*\*RPC(Remote
Procedure Call)\*\*なのです。

![](https://storage.googleapis.com/zenn-user-upload/01261317871d-20220403.png){.md-img
loading="lazy"}

# gPRCとは

このRPCの考え方は、ただの机上の空論ではありません。
実際にこのRPCのやり方でサービス間通信を行うために、様々なプロコトルが考えられました。

その中の一つ、Googleが開発・提案したRPCのプロトコルが**gRPC**です。
つまりgRPCとは、RPCを具現化するための方式の一つということなのです。

## gRPCが用いる技術

gRPCがRPCを実現させるために使っている技術は、大きく分けて2つ存在します。

-   HTTP/2
-   Protocol Buffers

### 通信方式 - HTTP/2

RPCを行うためには、以下2つをどうにかして行う必要があります。

-   クライアントからサーバーに、呼び出す関数と引数の情報を伝える
-   サーバーからクライアントに、戻り値の情報を伝える

gRPCでは、HTTP/2のPOSTリクエストとそのレスポンスを使ってこれを実現しています。

-   呼び出す関数の情報: リクエストのパスに含める
-   呼び出す関数に渡す引数: HTTPリクエストボディに含める
-   呼び出した関数の戻り値: HTTPレスポンスボディに含める
    ![](https://storage.googleapis.com/zenn-user-upload/600fbff79649-20220403.png){.md-img
    loading="lazy"}

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAxMDEgMTAxIiByb2xlPSJpbWciIGFyaWEtbGFiZWw9Im1lc3NhZ2UiIGNsYXNzPSJtc2ctaWNvbiI+PGNpcmNsZSBjeD0iNTEiIGN5PSI1MSIgcj0iNTAiIGZpbGw9ImN1cnJlbnRDb2xvciI+PC9jaXJjbGU+PHRleHQgeD0iNTAlIiB5PSI1MCUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiNmZmZmZmYiIGZvbnQtc2l6ZT0iNzAiIGZvbnQtd2VpZ2h0PSJib2xkIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCI+ITwvdGV4dD48L3N2Zz4=){.msg-icon}


gRPCで通信する際にHTTP/2ではどのようなデータフレームになっているのかは、詳細が以下の公式ドキュメントに記載されています。
[https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md){target="_blank"
rel="nofollow noopener noreferrer"}


### シリアライズ方式 - Protocol Buffers

gRPCでは、呼び出した関数の引数・戻り値の情報は、そのままプレーンテキストで書くのではなく、Protocol
Buffersというシリアライズ方式を用いて変換した内容をリクエスト・レスポンスボディに含めることになっています。
![](https://storage.googleapis.com/zenn-user-upload/e3c554dc293b-20220403.png){.md-img
loading="lazy"}



脚注


1.  :::
    Procedureを「戻り値のない関数」とする流派もあるようですが、gRPCの文脈では戻り値ありの関数もProcedureとして見るのが適切かと思いますので今回はこのスタンスで進めたいと思います。
    [↩︎](#fnref-8529-1){.footnote-backref}
    :::




