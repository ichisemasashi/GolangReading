
# サーバーストリーミングの実装

[]{style="display:block;width:1px;height:0.8rem;flex-shrink:0"}[](/hsaki){.UserLinkSmall_container__PkgaY}


![さき(H.Saki)](https://res.cloudinary.com/zenn/image/fetch/s--FESoQ9n2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_70/https://storage.googleapis.com/zenn-user-upload/avatar/51291e09a0.jpeg){.AvatarImage_border__33_UE
.AvatarImage_plain__BCJNs width="35" height="35" loading="lazy"
referrerpolicy="no-referrer"}




さき(H.Saki)



2022.06.19に更新






[]{style="display:block;width:1px;height:2.7rem;flex-shrink:0"}



このチャプターの目次![](data:image/svg+xml;base64,PHN2ZyB2aWV3Ym94PSIwIDAgMjcgMjciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgY2xhc3M9IkNoYXB0ZXJUb2NfdG9nZ2xlSWNvbl9fNERfVlQiPjxwYXRoIGZpbGw9ImN1cnJlbnRDb2xvciIgZD0iTTEyLjc0IDIwLjUzbC05LjI2LTkuMThhLjc1Ljc1IDAgMDEwLTEuMDdsMS4yMy0xLjIzYS43NS43NSAwIDAxMS4wNyAwbDcuNDkgNy40MSA3LjQ5LTcuNDFhLjc0Ljc0IDAgMDExLjA2IDBsMS4yNCAxLjIzYS43Ny43NyAwIDAxMCAxLjA3bC05LjI2IDkuMThhLjc0Ljc0IDAgMDEtMS4wNiAweiI+PC9wYXRoPjwvc3ZnPg==){.ChapterToc_toggleIcon__4D_VT}



1.  [この章について](#%E3%81%93%E3%81%AE%E7%AB%A0%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)
2.  [メソッドの追加処理](#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%AE%E8%BF%BD%E5%8A%A0%E5%87%A6%E7%90%86)
    1.  [protoファイルでの定義](#proto%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A7%E3%81%AE%E5%AE%9A%E7%BE%A9)
    2.  [サーバーストリーミングメソッド用のコードを自動生成させる](#%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E7%94%A8%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E8%87%AA%E5%8B%95%E7%94%9F%E6%88%90%E3%81%95%E3%81%9B%E3%82%8B)
3.  [サーバーサイドの実装](#%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%B5%E3%82%A4%E3%83%89%E3%81%AE%E5%AE%9F%E8%A3%85)
    1.  [自動生成されたコード](#%E8%87%AA%E5%8B%95%E7%94%9F%E6%88%90%E3%81%95%E3%82%8C%E3%81%9F%E3%82%B3%E3%83%BC%E3%83%89)
    2.  [サーバーサイドのビジネスロジックを実装する](#%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%B5%E3%82%A4%E3%83%89%E3%81%AE%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B)
4.  [gRPCurlを用いたサーバーサイドの動作確認](#grpcurl%E3%82%92%E7%94%A8%E3%81%84%E3%81%9F%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%B5%E3%82%A4%E3%83%89%E3%81%AE%E5%8B%95%E4%BD%9C%E7%A2%BA%E8%AA%8D)
5.  [クライアントコードの実装](#%E3%82%AF%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%83%88%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E5%AE%9F%E8%A3%85)
    1.  [自動生成されたコード](#%E8%87%AA%E5%8B%95%E7%94%9F%E6%88%90%E3%81%95%E3%82%8C%E3%81%9F%E3%82%B3%E3%83%BC%E3%83%89-1)
    2.  [クライアントの実装](#%E3%82%AF%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%83%88%E3%81%AE%E5%AE%9F%E8%A3%85)
6.  [実装したクライアントの挙動確認](#%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%9F%E3%82%AF%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%83%88%E3%81%AE%E6%8C%99%E5%8B%95%E7%A2%BA%E8%AA%8D)






# この章について

ここからは、実際にストリーミング処理を実装して動かしていきます。
まずこの章では、サーバーストリーミングから見ていきます。

具体的には、Unary
RPCだった`Hello`メソッドの他に、サーバーストリーミングを行う`HelloServerStream`メソッドを作っていきましょう。

# メソッドの追加処理

## protoファイルでの定義

まずは、protoファイルに`HelloServerStream`メソッドの定義を記述します。



[api/hello.proto]{.code-block-filename}


```
service GreetingService {
    // サービスが持つメソッドの定義
    rpc Hello (HelloRequest) returns (HelloResponse);
+   // サーバーストリーミングRPC
+    rpc HelloServerStream (HelloRequest) returns (stream HelloResponse);
}
```


今回はサーバーストリーミングですので、一つのリクエストに複数個のレスポンスが返ってくる形態です。
それを表現するために、レスポンスを表す戻り値の定義のところに`stream`とつけています。

## サーバーストリーミングメソッド用のコードを自動生成させる

protoファイルの修正が終わったところで、`HelloServerStream`メソッド用のコードを自動生成で作りましょう。
もう一度以下の`protoc`コマンドを実行します。


``` language-bash
$ cd api
$ protoc --go_out=../pkg/grpc --go_opt=paths=source_relative \
    --go-grpc_out=../pkg/grpc --go-grpc_opt=paths=source_relative \
    hello.proto
```


![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAxMDEgMTAxIiByb2xlPSJpbWciIGFyaWEtbGFiZWw9Im1lc3NhZ2UiIGNsYXNzPSJtc2ctaWNvbiI+PGNpcmNsZSBjeD0iNTEiIGN5PSI1MSIgcj0iNTAiIGZpbGw9ImN1cnJlbnRDb2xvciI+PC9jaXJjbGU+PHRleHQgeD0iNTAlIiB5PSI1MCUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiNmZmZmZmYiIGZvbnQtc2l6ZT0iNzAiIGZvbnQtd2VpZ2h0PSJib2xkIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCI+ITwvdGV4dD48L3N2Zz4=){.msg-icon}


`protoc`コマンドで変更が加えられるのは`pkg/grpc`フォルダのファイルのみです。
そして、

-   `pkg/grpc`フォルダのファイルに手動で変更を加えていない
-   ビジネスロジックを実装しているのは`api`ディレクトリ下のファイルのみ

なので、`protoc`コマンドで何度もコードの生成を繰り返したとしても、自分で書いたサーバーコードが壊れてしまうことはありません。


# サーバーサイドの実装

ここからは、gRPCサーバーの中に`HelloServerStream`メソッドを付け加えるように実装を追加していきます。

## 自動生成されたコード

自動生成されたコードは、元々あった`GreetingServiceServer`サービスに`HelloServerStream`メソッドが追加されたものになります。



[pkg/grpc/hello_grpc.pb.go]{.code-block-filename}


```
type GreetingServiceServer interface {
    // サービスが持つメソッドの定義
    Hello(context.Context, *HelloRequest) (*HelloResponse, error)
+ // サーバーストリーミングRPC
+    HelloServerStream(*HelloRequest, GreetingService_HelloServerStreamServer) error
 mustEmbedUnimplementedGreetingServiceServer()
}
```


引数として`HelloRequest`型を渡すところはUnary
RPCである`Hello`メソッドと同じです。
ただ、ストリーミングにした戻り値から`HelloResponse`型がなくなりエラーだけになっています。

その代わりに、第二引数に`GreetingService_HelloServerStreamServer`インターフェースというものが加わりました。



[pkg/grpc/hello_grpc.pb.go]{.code-block-filename}


``` language-go
// 自動生成された、サーバーストリーミングのためのインターフェース(for サーバー)
type GreetingService_HelloServerStreamServer interface {
    Send(*HelloResponse) error
    grpc.ServerStream
}
```


この`GreetingService_HelloServerStreamServer`インターフェースを使って、どのようにレスポンスをクライアントに返していくのかについては後ほど説明します。

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAxMDEgMTAxIiByb2xlPSJpbWciIGFyaWEtbGFiZWw9Im1lc3NhZ2UiIGNsYXNzPSJtc2ctaWNvbiI+PGNpcmNsZSBjeD0iNTEiIGN5PSI1MSIgcj0iNTAiIGZpbGw9ImN1cnJlbnRDb2xvciI+PC9jaXJjbGU+PHRleHQgeD0iNTAlIiB5PSI1MCUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiNmZmZmZmYiIGZvbnQtc2l6ZT0iNzAiIGZvbnQtd2VpZ2h0PSJib2xkIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCI+ITwvdGV4dD48L3N2Zz4=){.msg-icon}


ちなみに、`GreetingService_HelloServerStreamServer`インターフェースは`Send`メソッド以外にも、[`grpc.ServerStream`](https://pkg.go.dev/google.golang.org/grpc#ServerStream){target="_blank"
rel="nofollow noopener noreferrer"}インターフェースが持つ以下のメソッドも追加で使うことができます。


``` language-go
type ServerStream interface {
    SetHeader(metadata.MD) error
    SendHeader(metadata.MD) error
    SetTrailer(metadata.MD)
    Context() context.Context
    SendMsg(m interface{}) error
    RecvMsg(m interface{}) error
}
```



## サーバーサイドのビジネスロジックを実装する

それでは、gRPCサービスの実態である自作構造体`myServer`型にも`HelloServerStream`メソッドを実装していきましょう。
`HelloServerStream`メソッドのシグネチャは、自動生成された`GreetingServiceServer`インターフェースに含まれていた`HelloServerStream`メソッドに従います。



[cmd/server/main.go]{.code-block-filename}


``` language-go
func (s *myServer) HelloServerStream(req *hellopb.HelloRequest, stream hellopb.GreetingService_HelloServerStreamServer) error {
    resCount := 5
    for i := 0; i < resCount; i++ {
        if err := stream.Send(&hellopb.HelloResponse{
            Message: fmt.Sprintf("[%d] Hello, %s!", i, req.GetName()),
        }); err != nil {
            return err
        }
        time.Sleep(time.Second * 1)
    }
    return nil
}
```


### レスポンス送信処理

特筆するべきなのは、クライアントにレスポンスを返す部分の記述が、第二引数として受け取った`stream`の`Send`メソッドになっているところです。
レスポンスを返したいときには、`Send`メソッドの引数に`HelloResponse型`を渡すことでそれがクライアントに送信されます。


``` language-go
// Unary RPCがレスポンスを返すところ
func (s *myServer) Hello(ctx context.Context, req *hellopb.HelloRequest) (*hellopb.HelloResponse, error) {
    // HelloResponse型を直接returnする
    return &hellopb.HelloResponse{
        Message: fmt.Sprintf("Hello, %s!", req.GetName()),
    }, nil
}

// Server Stream RPCがレスポンスを返すところ
func (s *myServer) HelloServerStream(req *hellopb.HelloRequest, stream hellopb.GreetingService_HelloServerStreamServer) error {
    // (一部抜粋)
    // streamのSendメソッドを使っている
    stream.Send(&hellopb.HelloResponse{
        Message: fmt.Sprintf("[%d] Hello, %s!", i, req.GetName()),
    })
}
```


`Send`メソッドを何度も実行することで何度もクライアントにレスポンスを返すことができ、これにてサーバーからのストリーミングを実現しています。
これがUnary RPCのときとの違いです。

### ストリームの終端

サーバー側から全てのデータを送信し終わったときには、`HelloServerStream`メソッドを`return`文で終わらせることでストリームを終わらせることができます。


``` language-go
// Unary RPCの通信終了時
func (s *myServer) Hello(ctx context.Context, req *hellopb.HelloRequest) (*hellopb.HelloResponse, error) {
    // HelloResponse型を1つreturnする
    // (Unaryなので、レスポンスを一つ返せば終わり)
    return &hellopb.HelloResponse{
        Message: fmt.Sprintf("Hello, %s!", req.GetName()),
    }, nil
}

// Server Stream RPCの通信終了時
func (s *myServer) HelloServerStream(req *hellopb.HelloRequest, stream hellopb.GreetingService_HelloServerStreamServer) error {
    // (略: レスポンス送信処理)

    // return文でメソッドを終了させる=ストリームの終わり
    return nil
}
```


![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAxMDEgMTAxIiByb2xlPSJpbWciIGFyaWEtbGFiZWw9Im1lc3NhZ2UiIGNsYXNzPSJtc2ctaWNvbiI+PGNpcmNsZSBjeD0iNTEiIGN5PSI1MSIgcj0iNTAiIGZpbGw9ImN1cnJlbnRDb2xvciI+PC9jaXJjbGU+PHRleHQgeD0iNTAlIiB5PSI1MCUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiNmZmZmZmYiIGZvbnQtc2l6ZT0iNzAiIGZvbnQtd2VpZ2h0PSJib2xkIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCI+ITwvdGV4dD48L3N2Zz4=){.msg-icon}


もちろん、ビジネスロジック部分の処理でエラーが発生した場合には`return err`してもOKです。


# gRPCurlを用いたサーバーサイドの動作確認

それでは、この`HelloServerStream`メソッドの動作確認をgRPCurlでやってみましょう。
サーバー起動を行った後に、以下のようにリクエストを送信します。


``` language-bash
$ grpcurl -plaintext -d '{"name": "hsaki"}' localhost:8080 myapp.GreetingService.HelloServerStream
{
  "message": "[0] Hello, hsaki!"
}
{
  "message": "[1] Hello, hsaki!"
}
{
  "message": "[2] Hello, hsaki!"
}
{
  "message": "[3] Hello, hsaki!"
}
{
  "message": "[4] Hello, hsaki!"
}
```


一度`'{"name": "hsaki"}'`というリクエストを送っただけで、サーバーからは5回レスポンスが続けて送られてきました。
これがサーバーストリーミングの挙動です。

# クライアントコードの実装

それでは今度は`HelloServerStream`メソッドを呼び出すようなクライアントコードを書いていきましょう。

## 自動生成されたコード

自動生成された`GreetingService`用のクライアントにも、`HelloServerStream`メソッドを呼び出すためのメソッドが追加されています。



[pkg/grpc/hello_grpc.pb.go]{.code-block-filename}


```
type GreetingServiceClient interface {
    // サービスが持つメソッドの定義
    Hello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, error)
+ // サーバーストリーミングRPC
+    HelloServerStream(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (GreetingService_HelloServerStreamClient, error)
}
```


引数として`HelloRequest`型を渡すところは、Unary
RPCである`Hello`メソッドと同じです。
ただ、サーバーから送られてくる複数個のレスポンスを受け取るために、戻り値が`GreetingService_HelloServerStreamClient`に変わっています。



[pkg/grpc/hello_grpc.pb.go]{.code-block-filename}


``` language-go
// 自動生成された、サーバーストリーミングのためのインターフェース(for クライアント)
type GreetingService_HelloServerStreamClient interface {
    Recv() (*HelloResponse, error)
    grpc.ClientStream
}
```


この`GreetingService_HelloServerStreamClient`インターフェースを使って、どのようにサーバーから返ってくる複数個レスポンス受け取るのかは後ほど説明します。

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAxMDEgMTAxIiByb2xlPSJpbWciIGFyaWEtbGFiZWw9Im1lc3NhZ2UiIGNsYXNzPSJtc2ctaWNvbiI+PGNpcmNsZSBjeD0iNTEiIGN5PSI1MSIgcj0iNTAiIGZpbGw9ImN1cnJlbnRDb2xvciI+PC9jaXJjbGU+PHRleHQgeD0iNTAlIiB5PSI1MCUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiNmZmZmZmYiIGZvbnQtc2l6ZT0iNzAiIGZvbnQtd2VpZ2h0PSJib2xkIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCI+ITwvdGV4dD48L3N2Zz4=){.msg-icon}


ちなみに、`GreetingService_HelloServerStreamClient`インターフェースは`Recv`メソッド以外にも、[`grpc.ClientStream`](https://pkg.go.dev/google.golang.org/grpc#ClientStream){target="_blank"
rel="nofollow noopener noreferrer"}インターフェース\[\^2\]が持つ以下のメソッドも追加で使うことができます。


``` language-go
type ClientStream interface {
    Header() (metadata.MD, error)
    Trailer() metadata.MD
    CloseSend() error
    Context() context.Context
    SendMsg(m interface{}) error
    RecvMsg(m interface{}) error
}
```



## クライアントの実装

それでは、クライアントに新しく追加された`HelloServerStream`メソッドを使って、gRPCサーバー上にある`HelloServerStream`メソッドを呼び出す処理を書いていきましょう。



[cmd/client/main.go]{.code-block-filename}


```
func main() {
    // (前略)
    for {
        fmt.Println("1: send Request")
+     fmt.Println("2: HelloServerStream")
-     fmt.Println("2: exit")
+      fmt.Println("3: exit")
     fmt.Print("please enter >")

        // (略)

        switch in {
        case "1":
            (略)

+     case "2":
+            HelloServerStream()

-        case "2":
+      case "3":
         fmt.Println("bye.")
            goto M
        }
    }
M:
}

+func HelloServerStream() {
+    fmt.Println("Please enter your name.")
+    scanner.Scan()
+    name := scanner.Text()
+
+    req := &hellopb.HelloRequest{
+        Name: name,
+    }
+    stream, err := client.HelloServerStream(context.Background(), req)
+    if err != nil {
+        fmt.Println(err)
+        return
+    }
+
+    for {
+        res, err := stream.Recv()
+        if errors.Is(err, io.EOF) {
+            fmt.Println("all the responses have already received.")
+            break
+        }
+
+        if err != nil {
+            fmt.Println(err)
+        }
+        fmt.Println(res)
+    }
+}
```


特筆するべき点について説明します。

### レスポンス受信処理

Unary
RPCのときは、サーバーからレスポンスは1回しか送られてこないので、gRPCクライアントが持つ`Hello`メソッドを一回呼ぶだけで直接レスポンスを得ることができました。
しかし、サーバーストリーミングの場合は、

1.  クライアントが持つ`HelloServerStream`メソッドを呼んで、サーバーからレスポンスが送られてくるストリーム(`GreetingService_HelloServerStreamClient`インターフェース型)を取得
2.  そのストリームの`Recv`メソッドを呼ぶことでレスポンスを得る

という2ステップが必要になります。


``` language-go
// Unary RPCがレスポンスを受け取るところ
func Hello() {
    // (一部抜粋)
    // Helloメソッドの実行 -> HelloResponse型のレスポンスresを入手
    res, err := client.Hello(context.Background(), req)
}

// Server Stream RPCがレスポンスを受け取るところ
func HelloServerStream() {
    // (一部抜粋)
    // サーバーから複数回レスポンスを受け取るためのストリームを得る
    stream, err := client.HelloServerStream(context.Background(), req)

    for {
        // ストリームからレスポンスを得る
        res, err := stream.Recv()
    }
}
```


### ストリームの終端

サーバーストリーミングといっても、いつまでも無限にレスポンスを受け取るわけではありません。
サーバーからもうこれ以上レスポンスは送られてきませんというタイミングは絶対に訪れます。

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAxMDEgMTAxIiByb2xlPSJpbWciIGFyaWEtbGFiZWw9Im1lc3NhZ2UiIGNsYXNzPSJtc2ctaWNvbiI+PGNpcmNsZSBjeD0iNTEiIGN5PSI1MSIgcj0iNTAiIGZpbGw9ImN1cnJlbnRDb2xvciI+PC9jaXJjbGU+PHRleHQgeD0iNTAlIiB5PSI1MCUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiNmZmZmZmYiIGZvbnQtc2l6ZT0iNzAiIGZvbnQtd2VpZ2h0PSJib2xkIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCI+ITwvdGV4dD48L3N2Zz4=){.msg-icon}


このタイミングはサーバーサイドのコードでいうと、`HelloServerStream`メソッドの`return`文が呼ばれたときになります。



[cmd/server/main.go]{.code-block-filename}


``` language-go
func (s *myServer) HelloServerStream(req *hellopb.HelloRequest, stream hellopb.GreetingService_HelloServerStreamServer) error {
    // (レスポンス送信処理)
    return nil
}
```



クライアントの方で「全てのレスポンスを受け取った」とどう判断するのでしょうか。
実際にその判断を行っているのは以下の箇所です。


``` language-go
res, err := stream.Recv()
if errors.Is(err, io.EOF) {
    fmt.Println("all the responses have already received.")
    break
}
```


`Recv`メソッドでレスポンスを受け取るとき、これ以上受け取るレスポンスがないという状態なら、第一戻り値には`nil`、第二戻り値の`err`には[`io.EOF`](https://pkg.go.dev/io#pkg-variables){target="_blank"
rel="nofollow noopener noreferrer"}が格納されています。


``` language-go
var EOF = errors.New("EOF")
```


そのため、`errors.Is`関数を用いて「エラーを受け取ったか&受け取ったエラーが`io.EOF`か」を確かめることで、後続のレスポンスの有無を判定することができます。

# 実装したクライアントの挙動確認

それでは、今作ったクライアントコードの挙動を確認してみます。


``` language-bash
$ cd cmd/client
$ go run main.go
start gRPC Client.

1: Hello
2: HelloServerStream
3: exit
please enter >2

Please enter your name.
hsaki
message:"[0] Hello, hsaki!"
message:"[1] Hello, hsaki!"
message:"[2] Hello, hsaki!"
message:"[3] Hello, hsaki!"
message:"[4] Hello, hsaki!"

1: Hello
2: HelloServerStream
3: exit
please enter >3

bye.
```


このように、ターミナルを通じてリクエスト送信・レスポンスの表示ができれば成功です。
きちんと複数個のレスポンスを受け取ることができました。




