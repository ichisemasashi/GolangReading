
# gRPCで実現できるストリーミング処理

[]{style="display:block;width:1px;height:0.8rem;flex-shrink:0"}[](/hsaki){.UserLinkSmall_container__PkgaY}


![さき(H.Saki)](https://res.cloudinary.com/zenn/image/fetch/s--FESoQ9n2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_70/https://storage.googleapis.com/zenn-user-upload/avatar/51291e09a0.jpeg){.AvatarImage_border__33_UE
.AvatarImage_plain__BCJNs width="35" height="35" loading="lazy"
referrerpolicy="no-referrer"}




さき(H.Saki)



2022.06.19に更新






[]{style="display:block;width:1px;height:2.7rem;flex-shrink:0"}



このチャプターの目次![](data:image/svg+xml;base64,PHN2ZyB2aWV3Ym94PSIwIDAgMjcgMjciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgY2xhc3M9IkNoYXB0ZXJUb2NfdG9nZ2xlSWNvbl9fNERfVlQiPjxwYXRoIGZpbGw9ImN1cnJlbnRDb2xvciIgZD0iTTEyLjc0IDIwLjUzbC05LjI2LTkuMThhLjc1Ljc1IDAgMDEwLTEuMDdsMS4yMy0xLjIzYS43NS43NSAwIDAxMS4wNyAwbDcuNDkgNy40MSA3LjQ5LTcuNDFhLjc0Ljc0IDAgMDExLjA2IDBsMS4yNCAxLjIzYS43Ny43NyAwIDAxMCAxLjA3bC05LjI2IDkuMThhLjc0Ljc0IDAgMDEtMS4wNiAweiI+PC9wYXRoPjwvc3ZnPg==){.ChapterToc_toggleIcon__4D_VT}



1.  [この章について](#%E3%81%93%E3%81%AE%E7%AB%A0%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)
2.  [gRPCで可能な4種類の通信方式](#grpc%E3%81%A7%E5%8F%AF%E8%83%BD%E3%81%AA4%E7%A8%AE%E9%A1%9E%E3%81%AE%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F)
    1.  [Unary RPC](#unary-rpc)
    2.  [Server streaming RPC](#server-streaming-rpc)
    3.  [Client streaming RPC](#client-streaming-rpc)
    4.  [Bidirectional streaming RPC](#bidirectional-streaming-rpc)
3.  [gRPCのストリーミングを支える技術](#grpc%E3%81%AE%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%9F%E3%83%B3%E3%82%B0%E3%82%92%E6%94%AF%E3%81%88%E3%82%8B%E6%8A%80%E8%A1%93)
    1.  [HTTP/2の「フレーム」](#http%2F2%E3%81%AE%E3%80%8C%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%80%8D)






# この章について

gRPCでは「1リクエスト-1レスポンス」という一般によく想像される通信方式以外にも、ストリーミングという通信も行うことができます。
ここでは、ストリーミングとはどんな通信なのか説明した上で、どのようにリクエストとレスポンスがN:Mになるような通信を実現しているのか、原理についても噛み砕いて説明します。

# gRPCで可能な4種類の通信方式

gRPCには4つの通信方式が存在します。

-   Unary RPC
-   Server streaming RPC
-   Client streaming RPC
-   Bidirectional streaming RPC

## Unary RPC

前章まで実装していた「1リクエスト-1レスポンス」の通信方法です。
一つリクエストを送ると一つレスポンスが返ってきてそれで終わりという、いわゆる「普通」の通信を想像してもらえればOKです。
![](https://storage.googleapis.com/zenn-user-upload/d61c97eab65e-20220610.png){.md-img
loading="lazy"}

## Server streaming RPC

クライアントから送られた1回のリクエストに対して、サーバーからのレスポンスが複数返ってくる通信方式です。

例えば「サーバー側からプッシュ通知を受け取る」という場面では、サーバーはクライアントに対して複数回データを送る必要が出てきます。
それを実現するにはサーバーストリーミングがぴったりです。
![](https://storage.googleapis.com/zenn-user-upload/81cffca3f96e-20220610.png){.md-img
loading="lazy"}

## Client streaming RPC

クライアントから複数回リクエストを送信し、サーバーがそれに対してレスポンスを1回返す通信方式です。
これは例えばクライアント側から複数回に分けてデータをアップロードして、全て受け取った段階でサーバーが一回だけOKと返すような用途が考えられます。
![](https://storage.googleapis.com/zenn-user-upload/8b638efce2f7-20220610.png){.md-img
loading="lazy"}

## Bidirectional streaming RPC

サーバー・クライアントともに任意のタイミングでリクエスト・レスポンスを送ることができる通信方式です。
WebSocketのような双方向通信をイメージしてもらえるとわかりやすいかと思います。
![](https://storage.googleapis.com/zenn-user-upload/34cbf0f187c5-20220611.png){.md-img
loading="lazy"}

クライアントからリクエストを送るストリームと、サーバーからレスポンスを返すストリームは独立なため、例えばping-pongのようなこともできますし、リクエストを全て受け取るまでレスポンスは返さない、といったこともできます。

> Since the two streams are independent, the client and server can read
> and write messages in any order.
> For example, a server can wait until it has received all of a client's
> messages before writing its messages, or the server and client can
> play "ping-pong" -- the server gets a request, then sends back a
> response, then the client sends another request based on the response,
> and so on.
>
> 出典:[gRPC公式サイト - Core concepts, architecture and
> lifecycle](https://grpc.io/docs/what-is-grpc/core-concepts/){target="_blank"
> rel="nofollow noopener noreferrer"}

# gRPCのストリーミングを支える技術

このような柔軟なストリーミング通信ができるのは、gRPCがHTTP/2のプロトコル上で実現されているからです。
ストリーミング処理がHTTP/2でどう実装されているかを簡単に説明します。

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAxMDEgMTAxIiByb2xlPSJpbWciIGFyaWEtbGFiZWw9Im1lc3NhZ2UiIGNsYXNzPSJtc2ctaWNvbiI+PGNpcmNsZSBjeD0iNTEiIGN5PSI1MSIgcj0iNTAiIGZpbGw9ImN1cnJlbnRDb2xvciI+PC9jaXJjbGU+PHRleHQgeD0iNTAlIiB5PSI1MCUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiNmZmZmZmYiIGZvbnQtc2l6ZT0iNzAiIGZvbnQtd2VpZ2h0PSJib2xkIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCI+ITwvdGV4dD48L3N2Zz4=){.msg-icon}


ちなみに、HTTP/2にも「一対のリクエスト-レスポンスのやり取りをするために使う仮想通信路」という意味でストリームという用語が存在します。
しかしこれは、「複数個のデータを継続的に送る」というgRPCでのストリームとは意味合いが全く別なので注意してください。


## HTTP/2の「フレーム」

HTTP/2では、送受信するデータを**フレーム**という単位に分割して扱っています。
フレームのフォーマットは以下のようになっています。
![](https://storage.googleapis.com/zenn-user-upload/9baa38f6b0f3-20220611.png){.md-img
loading="lazy"}

gRPCのストリームについて説明するためには、タイプフィールドとフラグフィールドが肝になります。

### フレームのタイプ

フレームにはいくつかの種類があり、そのフレームがどれにあたるのかをタイプフィールドに格納して示しています。
全部で10種類のフレームタイプが定義されていますが、その中で特によく使われるのが以下の2種類です。

-   DATAフレーム: リクエスト/レスポンスのボディを送信するフレーム
-   HEADERSフレーム: リクエスト/レスポンスのヘッダーを送信するフレーム

この2つのフレームを使って、

1.  最初にHEADERフレームを送る
2.  リクエストのボディを複数個のDATAフレームに分けて送信する
3.  (レスポンス送信の場合のみ)gRPCステータスを含んだ最後のHEADERフレームを送る

という形で、クライアントやサーバーが複数回に分けてデータを送信するというgRPCのストリームの挙動を実現しています。

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAxMDEgMTAxIiByb2xlPSJpbWciIGFyaWEtbGFiZWw9Im1lc3NhZ2UiIGNsYXNzPSJtc2ctaWNvbiI+PGNpcmNsZSBjeD0iNTEiIGN5PSI1MSIgcj0iNTAiIGZpbGw9ImN1cnJlbnRDb2xvciI+PC9jaXJjbGU+PHRleHQgeD0iNTAlIiB5PSI1MCUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiNmZmZmZmYiIGZvbnQtc2l6ZT0iNzAiIGZvbnQtd2VpZ2h0PSJib2xkIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCI+ITwvdGV4dD48L3N2Zz4=){.msg-icon}


「gRPCステータス」が何者なのかについては11章で説明します。


### フレームのフラグ

このように、HTTP/2では1つの送受信データを複数個のフレームに分割してやり取りします。
そのため「このフレームで送るデータは最後です」ということを、どこかのタイミングで知らせてやる必要があります。

gRPCのストリーミングでは、送信する最後のフレームのフラグフィールドに`END_STREAM`フラグをつけることで、「もう送るデータがありません」という状況を相手に知らせるようになっています。



