\section{MySQL Database}

\subsection{はじめに}

ある時点で、あなたのWebアプリケーションは、データベースからデータを保存し、取得する必要があります。これは、動的なコンテンツを扱うとき、ユーザーがデータを入力するためのフォームを提供するとき、またはユーザーが認証するためのログインとパスワードの認証情報を保存するとき、ほとんど常にそうです。この目的のために、私たちはデータベースを用意しています。

データベースには、あらゆる形態と形があります。ウェブ上で一般的に使用されているデータベースは、MySQLデータベースです。MySQLは古くから存在し、その地位と安定性を数え切れないほど証明してきました。

この例では、Goでのデータベースアクセスの基礎に飛び込み、データベーステーブルを作成し、データを保存し、再びそれを取得します。

\subsection{go-sql-driver/mysqlパッケージをインストールする}

プログラミング言語 Go には、あらゆる種類の SQL データベースを照会するための `database/sql` という便利なパッケージが付属しています。これは、一般的な SQL の機能をすべて抽象化し、単一の API として利用できるようにしたもので、便利なものです。Goに含まれていないのは、データベースドライバです。Go では、データベースドライバは特定のデータベース (ここでは MySQL) の低レベルの詳細を実装するパッケージです。すでにお気づきかもしれませんが、これは前方互換性を保つのに便利です。なぜなら、すべてのGoパッケージを作成した時点で、作者は将来すべてのデータベースが実用化されることを予見することができず、世の中に存在するすべてのデータベースをサポートすることは、大量のメンテナンス作業となるためです。

MySQLデータベースドライバをインストールするには、任意のターミナルで以下を実行してください。


\begin{lstlisting}[numbers=none]
go get -u github.com/go-sql-driver/mysql
\end{lstlisting}

\subsection{MySQLデータベースへの接続}

必要なパッケージをインストールした後、最初に確認することは、MySQLデータベースに正常に接続できるかということです。もし、MySQLデータベースサーバがまだ稼働していない場合は、Dockerで簡単に新しいインスタンスを立ち上げることができます。DockerのMySQLイメージの公式ドキュメントはこちらです： https://hub.docker.com/\_/mysql

データベースに接続できるかどうかを確認するために、database/sql と go-sql-driver/mysql パッケージをインポートして、以下のように接続を開きます。


\begin{lstlisting}[numbers=none]
import "database/sql"
import _ "go-sql-driver/mysql"


// データベース接続の設定（常にエラーチェックを行う）
db, err := sql.Open("mysql", \\
"username:password@(127.0.0.1:3306)/dbname?parseTime=true")



// データベースへの最初の接続を初期化し、
// すべてが正しく動作するかどうかを確認します。
// 必ずエラーを確認してください。
err := db.Ping()
\end{lstlisting}


\subsection{最初のデータベーステーブルを作成する}

データベース内のすべてのデータ項目は、特定のテーブルに保存されます。データベースのテーブルは、列と行で構成されています。列は各データエントリにラベルを与え、その種類を指定します。行は、挿入されたデータ値です。最初の例では、このようなテーブルを作成したいと思います。

\begin{tabular}{|c|c|c|c|}\hline
    id & username & password & created\_at\\ \hline
    1 & johndoe & secret & 2019-08-10 12:30:00\\ \hline
\end{tabular}

SQLに置き換えると、テーブルを作成するコマンドは次のようになります。


\begin{lstlisting}[numbers=none]
CREATE TABLE users (
    id INT AUTO_INCREMENT,
    username TEXT NOT NULL,
    password TEXT NOT NULL,
    created_at DATETIME,
    PRIMARY KEY (id)
);
\end{lstlisting}

SQLコマンドができたので、\texttt{database/sql}パッケージを使用して、MySQLデータベースにテーブルを作成することができます。


\begin{lstlisting}[numbers=none]
    query := `
    CREATE TABLE users (
        id INT AUTO_INCREMENT,
        username TEXT NOT NULL,
        password TEXT NOT NULL,
        created_at DATETIME,
        PRIMARY KEY (id)
    );`

// データベース内のSQLクエリを実行します。
// err をチェックして、エラーがないことを確認します。
_, err := db.Exec(query)
\end{lstlisting}



\subsection{最初のユーザーを挿入する}

SQLに慣れている人なら、テーブルへの新しいデータの挿入は、テーブルを作成するのと同じくらい簡単です。一つ注意すべきことがあります。デフォルトでは、Go は SQL クエリに動的なデータを挿入するためにプリペアド ステートメントを使用します。これは、ユーザーが提供したデータを破損するリスクなしに安全にデータベースに渡すための方法です。ウェブプログラミングの初期には、プログラマがクエリで直接データをデータベースに渡していましたが、これは巨大な脆弱性を引き起こし、ウェブアプリケーション全体を破壊する可能性がありました。そのようなことはしないでください。正しく理解するのは簡単です。

最初のユーザーをデータベースのテーブルに挿入するために、次のような SQL クエリーを作成します。ご覧のとおり、id カラムは MySQL によって自動的に設定されるため、省略しました。クエスチョンマークは、SQLドライバに実際のデータに対するプレースホルダであることを伝えます。ここで、先ほど説明したプリペアドステートメントを見ることができます。



\begin{lstlisting}[numbers=none]
INSERT INTO users (username, password, created_at) VALUES (?, ?, ?)
\end{lstlisting}

この SQL クエリを Go で使用し、テーブルに新しい行を挿入することができます。


\begin{lstlisting}[numbers=none]
import "time"

username := "johndoe"
password := "secret"
createdAt := time.Now()

// データをusersテーブルに挿入し、その結果と考えられるエラーを返します。
// 結果には、最後に挿入された ID (自動生成されたもの) と、
// このクエリが影響を与えた行数に関する情報が含まれています。
result, err := db.Exec(`INSERT INTO users (username, password,\\
created_at) VALUES (?, ?, ?)`, username, password, createdAt)
\end{lstlisting}

新しく作成されたユーザーのIDを取得するには、次のようにします。


\begin{lstlisting}[numbers=none]
userID, err := result.LastInsertId()
\end{lstlisting}


\subsection{ユーザーテーブルの問い合わせ}

さて、テーブルの中にユーザーがいるわけですから、そのユーザーに問い合わせをして、すべての情報を取り戻したいと思います。Go では、テーブルへの問い合わせに 2 つの方法を用意しています。\texttt{db.Query}は複数行の問い合わせが可能です。また、特定の行だけを問い合わせたい場合は、\texttt{db.QueryRow}を使用します。

特定の行への問い合わせは、基本的にこれまで説明した他のSQLコマンドと同じように動作します。
IDで一人のユーザーを検索するSQLコマンドは次のようになります。


\begin{lstlisting}[numbers=none]
SELECT id, username, password, created_at FROM users WHERE id = ?
\end{lstlisting}

Goでは、まずデータを格納するための変数を宣言し、次のようにデータベースの1行に問い合わせを行います。


\begin{lstlisting}[numbers=none]
var (
    id        int
    username  string
    password  string
    createdAt time.Time
)

// データベースに問い合わせを行い、値を変数にスキャンします。
// エラーをチェックするのを忘れないでください。
query := `SELECT id, username, password, \\
          created_at FROM users WHERE id = ?`
err := db.QueryRow(query, 1).Scan(&id, &username,\\
                          &password, &createdAt)
\end{lstlisting}



\subsection{全ユーザーを問い合わせる}

前のセクションでは、単一のユーザー行を照会する方法について説明しました。多くのアプリケーションでは、既存のすべてのユーザーに問い合わせを行いたい場合があります。これは、上の例と同じように動作しますが、もう少しコーディングが必要です。

上の例の SQL コマンドを使用して、WHERE 句を切り落とします。この方法では、既存のすべてのユーザーを照会することができます。

\begin{lstlisting}[numbers=none]
SELECT id, username, password, created_at FROM users
\end{lstlisting}

Goでは、まずデータを格納するための変数を宣言し、次のようにデータベースの1行に問い合わせを行います。

\begin{lstlisting}[numbers=none]
type user struct {
    id        int
    username  string
    password  string
    createdAt time.Time
}

rows, err := db.Query(`SELECT id, username,\\
    password, created_at FROM users`) // check err
defer rows.Close()

var users []user
for rows.Next() {
    var u user
    err := rows.Scan(&u.id, &u.username, \\
        &u.password, &u.createdAt) // check err
    users = append(users, u)
}
err := rows.Err() // check err
\end{lstlisting}

今のusersスライスには、次のようなものが含まれているかもしれません。

\begin{lstlisting}[numbers=none]
users {
    user {
        id:        1,
        username:  "johndoe",
        password:  "secret",
        createdAt: time.Time{wall: 0x0,
                              ext: 63701044325,
                              loc: (*time.Location)(nil)},
    },
    user {
        id:        2,
        username:  "alice",
        password:  "bob",
        createdAt: time.Time{wall: 0x0,
                              ext: 63701044622,
                              loc: (*time.Location)(nil)},
    },
}
\end{lstlisting}

\subsection{テーブルからuserを削除する}

最後に、テーブルからuserを削除するのは、上のセクションの \texttt{.Exec} と同じように簡単です。


\begin{lstlisting}[numbers=none]
_, err := db.Exec(`DELETE FROM users WHERE id = ?`, 1)
          // check err
\end{lstlisting}







