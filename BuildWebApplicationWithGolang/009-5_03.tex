上の"よりよい方法"は数年前には十分安全な方法であったかもしれません。攻撃者はこれほど多くの\texttt{rainbow table}を作成するだけの十分なリソースが無かったためです。しかし、今日に至っては並列計算能力の向上によりこのような攻撃はすでにまったくもって可能です。

どうやってこの問題解決するのでしょうか？時間とリソースが許せば、クラックできないパスワードはありません。ですので方法は：故意にパスワードの計算に必要となるリソースと時間を増加させることによって、誰にも\texttt{rainbow table}を作成するのに必要となるリソースを与えないようにするのです。

この方法にはひとつの特徴があります。アルゴリズムにはどれも因子があります。パスワードのダイジェストを計算するのに必要となるリソースと時間を説明するのに使われ、計算強度でもあります。計算強度が大きければ大きいほど、攻撃者が\texttt{rainbow table}を作成するのが困難になり、ついには継続できなくなります。

ここでは\texttt{scrypt}の方法をおすすめしましょう。\texttt{scrypt}は有名なFreeBSDハッカーであるColin Percivalが彼の予備のサービスとしてTarsnapで開発しました。

現在Go言語でサポートされているライブラリ\texttt{http://code.google.com/p/go/source/browse?repo=crypto\#hg\%2Fscrypt}

\begin{lstlisting}[numbers=none]
dk := scrypt.Key([]byte("some password"), []byte(salt), 16384, 8, 1, 32)
\end{lstlisting}

上の方法によってユニークな対応するパスワードの値を取得することができます。これは現在までもっともクラックが難しいものです。

