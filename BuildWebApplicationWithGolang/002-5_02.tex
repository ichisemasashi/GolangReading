ではここで、SetColorのメソッドを見なおしてみましょう。このreceiverはBoxのポインタをさしています。そうです。*Boxを使えるのです。どうしてBox本体ではなくポインタを使うのでしょうか？

SetColorを定義した本当の目的はこのBoxの色を変更することです。もしBoxのポインタを渡さなければ、SetColorが受け取るのは実はBoxのコピーになってしまいます。つまり、メソッド内で色の変更を行うと、Boxのコピーを操作しているだけで、本当のBoxではないのです。そのため、ポインタを渡す必要があります。

ここではreceiverをメソッドの第一引数にしました。こうすれば前の関数で説明した値渡しと参照渡しも難しくなくなるでしょう。

もしかしたらSetColor関数の中で以下のように定義すべきじゃないかと思われたかもしれません。\texttt{*b.Color=c}、ところが\texttt{b.Color=c}でよいのです。ポインタに対応する値を読み込むことが必要ですから。

そのとおりです。Goの中ではこの２つの方法はどちらも正しいのです。ポインタを使って対応するフィールドにアクセスした場合（ポインタになんのフィールドがなかったとしても）、Goはあなたがポインタを通してその値を必要としていることを知っています。どうです。Goのデザインに魅了されてきたんじゃないですか？

注意深い読者はこのように思うかもしれません。PointItBlackの中でSetColorをコールした時、ひょっとして\texttt{(\&bl[i]).SetColor(BLACK)}と書かなければならないんじゃないかと。SetColorのreceiverは*Boxであり、Boxではありませんから。

ええ、その通りなんです。この２つの方法はどちらでもかまいません。Goはreceiverがポインタであることを知っています。こいつは自動的に解釈してくれるのです。

つまり：

\begin{quote}
もしメソッドのreceiverが*Tであれば、T型のエンティティの変数V上でこのメソッドをコールすることができます。\&Vによってメソッドをコールする必要はありません。
\end{quote}



\begin{quote}
もしメソッドのreceiverがTであれば、T型の変数P上でこのメソッドをコールすることができます。Pを使ってメソッドをコールする必要はありません。
\end{quote}

ですので、コールしているポインタのメソッドがポインタのメソッドであるかどうかは気にする必要がありません。Goはあなたが行おうとしているすべてのことを知っているのです。C/C++でプログラムを経験されてこられた方にとっては、とてもとても大きな苦痛が解決されることでしょう。
