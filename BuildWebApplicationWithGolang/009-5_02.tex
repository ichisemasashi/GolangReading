上ではハッカーが\texttt{rainbow table}を使用することでハッシュされたパスワードをクラックできるとご紹介しました。大抵の場合は暗号化時に使用されたハッシュアルゴリズムが公開されているものであることが原因です。もしハッカーが暗号化のハッシュアルゴリズムが何かを知らなければ、どこから手をつけてよいかわかりません。

直接的な解決方法の一つは、自分でハッシュアルゴリズムをデザインすることです。しかしながら、優良なハッシュアルゴリズムはとてもデザインが難しいのです- - 衝突を避けなければなりませんし、分かりやすいルールであってもいけません。この２つを満たすのは想像よりもずっと困難です。そのため、実際のアプリケーションでは既存のハッシュアルゴリズムを利用して複数回ハッシュすることが行われます。

しかし単純な複数回ハッシュでは、ハッカーを止めることはできません。二回のMD5や三回のMD5といった我々でも思いつく方法は、ハッカーも当然思いつきます。特にいくつかのオープンソースに対しては、このようなハッシュは直接アルゴリズムをハッカーに告げているのと同じことです。

破られない盾はありません。しかし折れない矛もまたありません。現在セキュリティが比較的優秀なウェブサイトはいずれも"ソルト"とよばれる方法によってパスワードを保存しています。よく言われる"salt"のことです。彼らの通常の方法はまずユーザが入力したパスワードに対してMD5（または他のハッシュアルゴリズム）で一度暗号化します。得られたMD5の値の前後に管理者自身だけが知っているランダムな文字列を追加して、再度MD5で暗号化します。このランダムな文字列にはなんらかの一定の文字列が含まれていてもかまいません。ユーザ名が含まれていてもかまいません。（各ユーザの暗号化に使用された秘密鍵が一致しないことを保証するために使用します）。

\begin{lstlisting}[numbers=none]
//import "crypto/md5"
//ユーザ名をabc、パスワードを123456とします
h := md5.New()
io.WriteString(h, "暗号化が必要なパスワード")

//pwmd5はe10adc3949ba59abbe56e057f20f883eです。
pwmd5 :=fmt.Sprintf("%x", h.Sum(nil))

//saltを２つ指定します： salt1 = @#$%   salt2 = ^&*()
salt1 := "@#$%"
salt2 := "^&*()"

//salt1+ユーザ名+salt2+MD5を連結します。
io.WriteString(h, salt1)
io.WriteString(h, "abc")
io.WriteString(h, salt2)
io.WriteString(h, pwmd5)

last :=fmt.Sprintf("%x", h.Sum(nil))
\end{lstlisting}

２つのsaltが漏洩していなければ、ハッカーはもし最後のこの暗号化された文字列を手に入れてもオリジナルのパスワードが何だったのか推測するのはほとんど不可能です。
