# ジェネリック入門

ロバート・グリーゼマー、イアン・ランス・テイラー\
22 March 2022
2022年 3月22日

## はじめに

このブログ記事は、GopherCon 2021での講演を元に作成されています。

Go 1.18 リリースでは、ジェネリックのサポートが追加されました。ジェネリックスは、最初のオープン ソース リリース以来、私たちが Go に加えた最大の変更点です。この記事では、新しい言語機能を紹介します。詳細をすべて網羅するつもりはありませんが、重要なポイントはすべて押さえるつもりです。多くの例を含む、より詳細で長い説明については、[提案ドキュメント]() を参照してください。言語の変更についてのより正確な説明は、[updated language spec]()を参照してください。(実際の1.18の実装では、提案文書で許可されていることにいくつかの制限が課せられていることに注意してください。将来のリリースでは、制限のいくつかが解除されるかもしれません)。

ジェネリックとは、使用する特定の型に依存しないコードを書くための方法です。関数や型は、一連の型のいずれかを使用するように記述することができる。

ジェネリックスによって、言語には3つの大きな特徴が新たに加わった。

1.  関数の型パラメーターと型
2. インターフェース型を，メソッドを持たない型も含めた型の集合として定義する。
3. 型推論により，関数呼び出し時に多くの場合型引数を省略できるようになった．

## 型パラメータ

関数や型に型パラメータを持たせることができるようになりました。型パラメータリストは，括弧の代わりに角括弧が使われることを除けば，普通のパラメータリストと同じように見えます．

これがどのように機能するかを示すために、浮動小数点数に対する基本的な非ジェネリック関数 `Min` から始めましょう。

```
func Min(x, y float64) float64 {
    if x < y {
        return x
    }
    return y
}
```

この関数は、型パラメータリストを追加することによって、ジェネリック(汎用的)なものにすることができます。この例では、単一の型パラメータ `T` を持つ型パラメータリストを追加し、 `float64` の用途を `T` に置き換えています。

```
import "golang.org/x/exp/constraints"

func GMin[T constraints.Ordered](x, y T) T {
    if x < y {
        return x
    }
    return y
}
```

このような書き方で、この関数を型引数で呼び出すことが可能になりました。

```
x := GMin[int](2, 3)
```

`GMin` に型引数、この場合は `int` を与えることを *instantiation* と呼びます。インスタンス化は2つのステップで行われます。まず、コンパイラはすべての型引数を総称関数や総称型全体のそれぞれの型パラメータに置き換えます。次に、コンパイラは各型引数がそれぞれの制約を満たしているかどうかを検証します。その意味については後ほど説明するが、もしこの2番目のステップが失敗すると、インスタンス化は失敗し、プログラムは無効となる。

インスタンス化に成功すると、他の関数と同じように呼び出すことができる非ジェネリック関数ができあがります。例えば、次のようなコードでは

```
fmin := GMin[float64]
m := fmin(2.71, 3.14)
```

インスタンス化した `GMin[float64]` は、実質的にオリジナルの浮動小数点数 `Min` 関数を生成し、関数呼び出しでそれを使用することができます。

型パラメータは型と一緒に使うこともできます。

```
type Tree[T interface{}] struct {
    left, right *Tree[T]
    value       T
}

func (t *Tree[T]) Lookup(x T) *Tree[T] { ... }

var stringTree Tree[string]
```

ここでは、ジェネリック型である `Tree` が型パラメータ `T` の値を格納している。 ジェネリック型は、この例でいう `Lookup` のようにメソッドを持つことができる。ジェネリック型を使用するには、インスタンス化する必要がある。 `Tree[string]` は、 `Tree` に型引数 `string` を与えてインスタンス化した例である。

## 型セット

型引数のインスタンス化に使用できる型引数について、もう少し深く見てみましょう。

通常の関数では、値のパラメータごとに型があり、その型によって値の集合が定義されます。例えば、上の非ジェネリック関数 `Min` のように `float64` 型を持つ場合、許容される引数の値の集合は、 `float64` 型で表現できる浮動小数点数の値の集合となります。

同様に、型パラメータリストも、それぞれの型パラメータに対して型を持ちます。 型パラメータはそれ自体が型であるため，型パラメータの型は型の集合を定義します．このメタタイプは、*型制約*と呼ばれます。

ジェネリックな `GMin` では、型制約は [constraints package]() からインポートされています。制約 `Ordered` は、順序付け可能な、言い換えれば `<` 演算子（または `<=` , `>` など）で比較可能な値を持つすべての型の集合を記述します。この制約により、順序付け可能な値を持つ型だけが `GMin` に渡されることが保証されます。また、`GMin`関数本体では、その型パラメーターの値が `<` 演算子との比較で使用できることを意味します。

Go では、型制約はインターフェースでなければなりません。つまり、インターフェース型は値型として使うこともできるし、メタ型として使うこともできる。 インタフェースはメソッドを定義するので、あるメソッドが存在することを要求する型制約を表現できるのは明らかです。しかし、`constraints.Ordered`もインターフェース型であり、`<`演算子はメソッドではありません。


これを実現するために、インターフェイスを新しい方法で見ていきます。

最近まで、Goの仕様では、インターフェースはメソッドセットを定義するとされていました。これは、おおよそインターフェースで列挙されたメソッドのセットです。これらのメソッドをすべて実装している型は、そのインターフェースを実装しています。

![](intro-generics/method-sets.png)

しかし、別の見方をすれば、インターフェースは型の集合、すなわちそれらのメソッドを実装する型を定義していると言えます。この観点からすると、インターフェイスの型集合の要素である任意の型は、 インターフェイスを実装していることになります。

![](intro-generics/type-sets.png)

この2つの見方は、同じ結果を導く。メソッドの集合ごとに、そのメソッドを実装する型の集合を想像することができ、それがインターフェースで定義された型の集合となります。

しかし、私たちの目的には、型集合のビューはメソッド集合のビューよりも利点があります：集合に明示的に型を追加することができるので、新しい方法で型集合を制御することができます。

私たちはこれを実現するために，インタフェース型の構文を拡張しました．例えば、 `interface{ int|string|bool }` は `int`, `string`, `bool` という型を含む型集合を定義します。

![](intro-generics/type-sets-2.png)

別の言い方をすると、このインターフェースは `int`, `string`, または `bool` だけが満たすことができる。

では、実際に `contraints.Ordered` の定義を見てみましょう。

```
type Ordered interface {
    Integer|Float|~string
}
```

この宣言は、 `Ordered` インターフェースがすべての整数型、浮動小数点型、および文字列型の集合であることを表している。縦棒は、型（この場合は型の集合）の和集合を表しています。`Integer` と `Float` は `constraints` パッケージで同様に定義されているインターフェース型である。なお、 `Ordered` インターフェースで定義されているメソッドはありません。

型制約では、通常、 `string` のような特定の型には興味がなく、すべての文字列型に興味があります。そのために `~` トークンがあります。`~string` という表現は、 `string` を基本型とするすべての型の集合を意味します。これには `string` という型そのものと、 `type MyString string` のような定義で宣言されたすべての型が含まれます。

もちろん、インターフェースでメソッドを指定したいし、後方互換性も確保したい。Go 1.18では、インターフェースは以前と同じようにメソッドと埋め込みインターフェースを含むことができますが、インターフェース以外の型、共用体、基礎となる型の集合を埋め込むこともできます。

型制約として使われる場合、インターフェースによって定義された型セットは、それぞれの型パラメーターの型引数として許可される型を正確に指定します。汎用関数本体の中で、オペランドの型が制約 `C` を持つ型パラメータ `P` である場合、操作は `C` の型セット内のすべての型によって許可されていれば許可されます（現在はここにいくつかの実装制限がありますが、通常のコードでは遭遇する可能性は低いでしょう）。

制約として使用されるインタフェースは、名前(`Ordered`など)が与えられることもあれば、型パラメータリストにインライン化されたリテラルなインタフェースであることもあります。例えば

```
[S interface{~[]E}, E interface{}]
```

ここで `S` は、その要素型が任意の型であるスライス型でなければならない。

これはよくあるケースなので、制約の位置にあるインターフェースでは、囲む `interface{}` は省略してもよく、単にこう書くことができる。

```
[S ~[]E, E interface{}]
```

空のインターフェイスは型パラメーターのリストや通常の Go コードではよくあることなので、Go 1.18 では空のインターフェイス型のエイリアスとして新しい事前宣言された識別子 `any` を導入しています。これにより、このような慣用的なコードになります。

```
[S ~[]E, E any]
```

型セットとしてのインターフェースは強力な新しいメカニズムであり、Goで型制約を機能させるための鍵となるものです。今のところ、新しい構文形式を使用するインターフェースは制約としてのみ使用できます。しかし、明示的に型制約されたインターフェースが一般的にどのように役に立つかは、想像に難くありません。

## 型推論

最後の大きな新機能は、型推論である。これはある意味で最も複雑な変更点だが、ジェネリック関数を呼び出すコードを書くときに自然なスタイルが使えるようになるという点で重要である。

### 関数の引数の型推論

型引数があると、型引数を渡す必要があり、冗長なコードになることがあります。ジェネリックな `GMin` 関数に戻りましょう。

```
func GMin[T constraints.Ordered](x, y T) T { ... }
```

型パラメータ `T` は、型でない通常の引数 `x` と `y` の型を指定するために使用されます。先に見たように、これは明示的な型引数で呼び出すことができます。

```
var a, b, m float64

m = GMin[float64](a, b) // explicit type argument
```

多くの場合、コンパイラは通常の引数から `T` の型引数を推論することができます。これによって、明確さを保ちつつ、コードを短くすることができる。

```
var a, b, m float64

m = GMin(a, b) // no type argument
```

これは、引数 `a` と `b` の型と、パラメータ `x` と `y` の型をマッチングさせることで実現する。

このように、関数への引数の型から型引数を推論することを *関数引数型推論* といいます。

関数引数型推論は、関数の引数で使われる型パラメータに対してのみ機能し、関数の結果でのみ使われる型パラメータや関数本体でのみ使われる型パラメータに対しては機能しない。例えば、 `MakeT[T any]() T` のように、結果にのみ `T` を使うような関数には適用されません。

### 制約条件付き型推論

この言語は、もう一つの型推論である*制約条件付き型推論*をサポートしています。これを説明するために、整数のスライスを拡大縮小する例から始めよう。

```
// Scaleは、各要素にcを乗じたsのコピーを返す。
// この実装には，これから見るように問題がある．
func Scale[E constraints.Integer](s []E, c E) []E {
    r := make([]E, len(s))
    for i, v := range s {
        r[i] = v * c
    }
    return r
}
```

これは、任意の整数型のスライスに対して動作するジェネリックな関数である。

ここで、多次元の `Point` 型があるとします。それぞれの `Point` は、点の座標を示す単純な整数のリストです。当然ながら、この型はいくつかのメソッドを持つことになります。

```
type Point []int32

func (p Point) String() string {
    // Details not important.
}
```

時には、`Point`を拡大縮小したいことがあります。`Point` は整数のスライスに過ぎないので、先ほど書いた `Scale` 関数を使用することができます。

```
// ScaleAndPrint は、Point を 2 倍にして出力します。
func ScaleAndPrint(p Point) {
    r := Scale(p, 2)
    fmt.Println(r.String()) // DOES NOT COMPILE
}
```

残念ながらこれはコンパイルできず、`r.String undefined (type []int32 has no field or method String)`のようなエラーで失敗してしまいます。

問題は、`Scale` 関数が `[]E` 型の値を返すことです。ここで、`E` は引数のスライスの要素型です。ここで、 `E` は引数のスライスの要素型です。 `Point` 型の値で `Scale` を呼び出すと、 `Point` 型ではなく、 `[]int32` 型の値が返されます。これは、ジェネリックコードの書き方に従っていますが、私たちが望むものではありません。

これを解決するには、 `Scale` 関数を変更して、スライス型の型パラメータを使用するようにしなければなりません。

```
// Scaleは，各要素にcを乗じたsのコピーを返す。
func Scale[S ~[]E, E constraints.Integer](s S, c E) S {
    r := make(S, len(s))
    for i, v := range s {
        r[i] = v * c
    }
    return r
}
```

新しい型パラメータ `S` を導入し、スライス引数の型としました。このパラメータは、スライス引数の型であり、 `[]E` ではなく `S` が基本型となるように制約しています。`E` は整数であるように制約されているので、その効果は以前と同じです：最初の引数は何らかの整数型のスライスでなければなりません。関数本体への唯一の変更は、 `make` を呼び出すときに `[]E` ではなく `S` を渡すようになったことです。

新しい関数はプレーンなスライスで呼び出した場合は以前と同じように動作しますが、 `Point` 型で呼び出した場合は、 `Point` 型の値が返されます。これは、私たちが欲しいものです。このバージョンの `Scale` では、以前の `ScaleAndPrint` 関数は期待通りにコンパイルされ実行されます。

しかし、なぜ明示的な型引数を渡さずに `Scale` の呼び出しを書いてもいいのか、と問うのはもっともなことです。つまり、なぜ `Scale[Point, int32](p, 2)` と書かずに、型引数なしで `Scale(p, 2)` と書くことができるのでしょうか？私たちの新しい `Scale` 関数には、 `S` と `E` という 2 つの型引数があります。型引数を渡さない `Scale` の呼び出しでは、上で説明した関数引数の型推論により、コンパイラは `S` の型引数が `Point` であることを推論します。しかし、この関数には型パラメータ `E` があり、これは乗算係数 `c` の型です。対応する関数の引数は `2` ですが、 `2` は *untyped* 定数なので、関数引数の型推論は `E` の正しい型を推論することができません（せいぜい `2` のデフォルト型である `int` を推論するくらいで、これは正しくありません）。 その代わりに、コンパイラが `E` の型引数がスライスの要素型であると推論するプロセスを *制約型推論* と呼びます。

制約型推論は、型パラメータの制約から型引数を推論します。これは、ある型パラメタが他の型パラメタで定義された制約を持っている 場合に使われる。それらの型パラメータのうちの1つの型引数が既知であるとき、その制約は他 の型引数を推論するために使用される。

これが適用される通常のケースは、ある制約がある型に対して `~`*`type`* という形式を使用し、その型が他の型パラメータを使用して記述されている場合です。これは `Scale` の例で見ることができます。`S` は `~[]E` で、これは `~` の後に他の型パラメータを使って `[]E` という型を記述したものです。 もし、 `S` の型引数がわかっていれば、 `E` の型引数を推論することができます。`S` はスライス型で、 `E` はそのスライスの要素型です。

これは制約型推論の紹介に過ぎません。詳細については、[提案文書]()文書または[言語仕様]()文書を参照してください。

### 型推論の実際

型推論の仕組みの詳細は複雑であるが、型推論を使うのは簡単である。成功すれば、型引数を省略することができ、ジェネリック関数の呼び出しも普通の関数の呼び出しと変わらないように見えます。型推論が失敗した場合は、コンパイラがエラーメッセージを出すので、その場合は必要な型引数を与えればよい。

型推論を言語に追加するにあたっては、推論の能力と複雑さのバランスを取るようにした。コンパイラが型を推論するとき、その型が決して驚くべきものでないことを保証したい。間違った型を推論してしまうことよりも、推論に失敗してしまうことのほうに注意を払おうとしてきた。おそらく完全に正しいとは言えないでしょうし、今後のリリースでも改良を続けていくかもしれません。その結果、より多くのプログラムが明示的な型引数なしで書けるようになるでしょう。今日型引数を必要としないプログラムは、明日も必要ないだろう。

## まとめ

Genericsは、1.18の大きな言語新機能です。この新しい言語の変更には、大量の新しいコードが必要で、実稼働環境での大きなテストは行われていません。これは、より多くの人々がジェネリックコードを書き、使用することによってのみ起こることでしょう。私たちは、この機能がよく実装され、高品質であると信じています。しかし、Goのほとんどの側面と違って、私たちはその信念を実際の経験で裏付けることができません。したがって、意味のあるところではジェネリックの使用を奨励しますが、ジェネリックコードを実運用にデプロイするときは、適切な注意を払ってください。

この注意はさておき、私たちはジェネリックを使えるようになったことに興奮していますし、ジェネリックによってGoプログラマの生産性が向上することを期待しています。


