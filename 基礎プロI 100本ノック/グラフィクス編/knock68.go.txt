// No. 68 マス目
// マス目の数（1以上の整数値）を入力させ、横600縦600のウィンドウを開き、ウィンドウの縦横がマス目の数に区切られるよう等間隔に線を描くプログラムを作成せよ。整数値の計算の場合、入力値によっては多少の誤差が生じるが、できるだけ誤差が小さくなるよう工夫せよ。
package main

import (
	"fmt"
	"image"
	"image/color"
	"log"

	"github.com/fogleman/gg"
	"github.com/hajimehoshi/ebiten/v2"
)

const (
	win_Width = 600
	win_Hight = 600
)

var (
	num_lines    int
	num_distance float64
)

func calcData() {
	fmt.Print("マス目の数: ")
	fmt.Scanf("%d", &num_lines)
	num_distance = float64(win_Width / num_lines)
}

func myImage() image.Image {
	// 指定された幅と高さの新しい image.RGBA を作成し、その画像にレンダリングするためのコンテキストを準備します。
	dc := gg.NewContext(win_Width, win_Hight)

	// 現在の色を設定します。r、g、bの値は0から1の間でなければなりません。
	dc.SetRGB(0, 0, 0)
	for i := 1; i < num_lines; i++ {
		x := num_distance * float64(i)
		dc.DrawLine(x, 0, x, win_Hight)
		y := num_distance * float64(i)
		dc.DrawLine(0, y, win_Width, y)
	}

	// 現在のパスを、現在の色、線幅、ラインキャップ、ラインジョイン、ダッシュの設定でストロークします。この操作の後、パスはクリアされます。
	dc.Stroke()
	return dc.Image()
}

// Game は ebiten.Game インターフェースを実装しています。
type Game struct{}

// Updateはゲーム状態を進行させる。
// Updateはtick毎（デフォルトでは1/60 [s]）に呼ばれる。
func (g *Game) Update() error {
	return nil
}

// Drawはゲーム画面を描画します。
// Drawはフレーム毎（60Hz表示の場合は通常1/60[s]）に呼び出されます。
func (g *Game) Draw(screen *ebiten.Image) {
	screen.Fill(color.White) // 背景色：白
	m := myImage()
	em := ebiten.NewImageFromImage(m)
	screen.DrawImage(em, &ebiten.DrawImageOptions{})
}

// Layoutは外部サイズ（ウィンドウサイズなど）を受け取り、（論理的な）画面サイズを返します。
// 外側のサイズで画面サイズを調整する必要がない場合は、固定サイズを返せばよい。
func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return win_Width, win_Hight
}

func main() {
	calcData()
	// ウィンドウサイズを任意に指定します。
	ebiten.SetWindowSize(win_Width, win_Hight)
	ebiten.SetWindowTitle("Hello, World!")
	// ebiten.RunGameを呼び出して、ゲームループを開始します。
	if err := ebiten.RunGame(&Game{}); err != nil {
		log.Fatal(err)
	}
}
