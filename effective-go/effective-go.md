# Effective Go

## はじめに

Goは新しい言語です。既存の言語からアイデアを借りていますが、特殊な性質を持っているため、効果的なGoプログラムは、親戚の言語で書かれたプログラムとは異なる性質を持っています。C++やJavaのプログラムを単純にGoに翻訳しても、満足のいく結果は得られないでしょう。一方、Goの視点から問題を考えれば、成功するかもしれないが、まったく違うプログラムができるかもしれない。つまり、Goをうまく書くためには、その特性やイディオムを理解することが重要です。また、名前の付け方や書式、プログラムの組み立て方など、Goでプログラミングするための確立された慣習を知っておくことも重要です。そうすれば、あなたが書いたプログラムは、他のGoプログラマーにとって理解しやすいものになるでしょう。

このドキュメントは、明快で慣用的なGoコードを書くためのヒントを提供します。最初に読むべき[言語仕様書](https://golang.org/ref/spec)、[Tour of Go](https://tour.golang.org/)、[How to Write Go Code](https://golang.org/doc/code.html)を補強するものです。

### 例

[Goパッケージソース](https://golang.org/src/)は、コアライブラリとしてだけでなく、言語の使い方の例としても役立つことを目的としています。さらに、多くのパッケージには、動作する自己完結型の実行例が含まれており、[golang.org](https://golang.org/)のウェブサイトから直接実行することができます。例えば、[this one](https://golang.org/pkg/strings/#example_Map)などです（必要に応じて、「Example」をクリックして開いてください）。問題にどのように取り組むか、何かをどのように実装するかについて疑問がある場合、ライブラリのドキュメント、コード、例題、答え、アイデア、背景を提供してくれます。

## フォーマットについて

フォーマットの問題は、最も議論の多い問題ですが、最も影響の少ない問題でもあります。人々は異なるフォーマットのスタイルに適応することができますが、その必要がない方が良いでしょうし、皆が同じスタイルを守っていれば、話題に割く時間も少なくて済みます。問題は、長い規定のスタイルガイドなしに、このユートピアにどうアプローチするかです。

Goでは通常とは異なるアプローチをとり、ほとんどのフォーマット問題を機械に任せています。`gofmt`プログラム（ソースファイルレベルではなくパッケージレベルで動作する`go fmt`としても利用可能）は、Goプログラムを読み、インデントや垂直方向の配置などの標準的なスタイルでソースを出力し、コメントを保持し、必要に応じて再フォーマットします。もし、答えが正しくないようであれば、プログラムを再構成して (あるいは、`gofmt` に関するバグを報告して)ください。わざわざ時間をかける必要はありません。

例えば，構造体の各フィールドのコメントを並べるのに時間をかける必要はありません．`Gofmt` がそのようにしてくれます。次のような宣言があるとします。

```go
type T struct {
    name string // name of the object
    value int // its value
}
```

`gofmt` は列を並べます。

```go
type T struct {
    name    string // name of the object
    value   int    // its value
}
```

標準パッケージのすべての Go コードは `gofmt` でフォーマットされています。

いくつかのフォーマットの詳細は残っています。とても簡単に言うと

- インデント
  - インデントにはタブを使用します。`gofmt` はデフォルトでタブを出力します。必要に応じてスペースを使用してください。
- 行の長さ
  - Go には行数の制限はありません。パンチカードから溢れてしまう心配はありません。行が長すぎると感じた場合は、行を折り返し、タブでインデントしてください。
- 括弧の数
  - 制御構造(`if`, `for`, `switch`)の構文には括弧がありませんので、GoはCやJavaよりも少ない括弧で済みます。また、演算子の優先順位の階層は、より短く、より明確になっています。だから
    ```go
     x<<8 + y<<16
    ```
    は、他の言語とは異なり、その間隔が意味するところを意味します。


## コメント

Goには、Cスタイルの `/* */` ブロックコメントとC++スタイルの `//` ラインコメントがあります。ブロックコメントは、主にパッケージのコメントとして表示されますが、式の中で使用したり、コードの大部分を無効にするのに便利です。

プログラム（およびウェブサーバー）の `godoc` は、Go のソースファイルを処理して、パッケージの内容に関するドキュメントを抽出します。トップレベルの宣言の前に現れるコメント（間に改行がない）は、宣言と一緒に抽出され、その項目の説明テキストとして使用されます。これらのコメントの性質やスタイルは、`godoc` が作成するドキュメントの品質を決定します。

すべてのパッケージは、パッケージ節の前のブロックコメントであるパッケージコメントを持つべきです。マルチファイルパッケージの場合、パッケージコメントは1つのファイルに存在するだけでよく、どのファイルでも構いません。パッケージコメントは、パッケージを紹介し、パッケージ全体に関連する情報を提供する必要があります。パッケージコメントは `godoc` ページで最初に表示され、その後に続く詳細なドキュメントを設定します。

```go
/*
Package regexp implements a simple library for regular expressions.

The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
```

パッケージがシンプルなものであれば、パッケージのコメントは簡潔で構いません。

```go
// Package path implements utility routines for
// manipulating slash-separated filename paths.
```

コメントには、星のバナーのような余分なフォーマットは必要ありません。生成される出力は、固定幅のフォントで表示されないこともありますので、アライメントをスペーシングに依存してはいけません。`godoc`は、`gofmt`と同様に、そのような処理を行います。コメントは解釈されないプレーンテキストですので、HTMLや `_this_` のような注釈はそのまま再現されますので、使わないようにしてください。`godoc`が行う調整の一つは、インデントされたテキストを固定幅のフォントで表示することで、プログラムのスニペットに適しています。[fmt パッケージ](https://golang.org/pkg/fmt/)のパッケージコメントでは、これが効果的に使われています。

文脈によっては、`godoc` はコメントを再フォーマットしないかもしれませんので、 正しいスペル、句読点、文の構造を使い、長い行を折りたたむなどして、 コメントが正しく見えるようにしてください。

パッケージ内では、トップレベルの宣言の直前にあるコメントは、その宣言のdocコメントとして機能します。プログラムの中でエクスポートされる（大文字の）名前には、必ず doc コメントを付ける必要があります。

doc コメントは完全な文として使うのが最も効果的で、さまざまな自動プレゼンテーションが可能になります。最初の文は、宣言される名前で始まる1文の要約でなければなりません。

```go
// Compile parses a regular expression and returns, if successful,
// a Regexp that can be used to match against text.
func Compile(str string) (*Regexp, error) {
```

すべてのdocコメントが説明する項目の名前で始まる場合、[go](https://golang.org/cmd/go/)ツールの[doc](https://golang.org/cmd/go/#hdr-Show_documentation_for_package_or_symbol)サブコマンドを使用して、出力を`grep`で実行することができます。「Compile」という名前は覚えていないが、正規表現の解析機能を探していたので、次のようなコマンドを実行したと想像してみてください。

```sh
$ go doc -all regexp | grep -i parse
```

パッケージ内のすべてのdocコメントが「この関数は...」で始まっていたら、`grep`では名前を覚えることができません。しかし、パッケージはそれぞれのドキュメントコメントを名前で始めているので、次のようなものが表示され、探している単語を思い出すことができます。

```
$ go doc -all regexp | grep -i parse
    Compile parses a regular expression and returns, if successful, a Regexp
    MustCompile is like Compile but panics if the expression cannot be parsed.
    parsed. It simplifies safe initialization of global variables holding
$
```

Goの宣言構文では、宣言をグループ化することができます。1つのdocコメントで、関連する定数や変数のグループを紹介することができます。宣言全体が提示されるので、このようなコメントはしばしばその場しのぎになってしまいます。

```go
// Error codes returned by failures to parse an expression.
var (
    ErrInternal      = errors.New("regexp: internal error")
    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
    ...
)
```

グループ化は、変数のセットがミューテックスで保護されていることなど、アイテム間の関係を示すこともできます。

```go
var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
```


## 名前

名前は、他の言語と同様、Goにおいても重要です。名前には意味上の効果もあります。パッケージの外にある名前の可視性は、その最初の文字が大文字かどうかで決まります。そのため、Goプログラムの命名規則について少し時間を割いてみましょう。

### パッケージ名

パッケージがインポートされると、パッケージ名がコンテンツへのアクセッサとなります。以降は

```go
import "bytes"
```

インポートされたパッケージは、`bytes.Buffer`について語ることができます。パッケージを使用する全員が、その内容を参照するために同じ名前を使用できると便利です。つまり、パッケージ名は、短く、簡潔で、連想させるような良い名前でなければなりません。慣習的に、パッケージには小文字の単一単語の名前が付けられます。アンダースコアや大文字小文字の混在は必要ありません。あなたのパッケージを使用するすべての人がその名前をタイプすることになるので、簡潔なものを選びましょう。また、先入観で衝突を心配する必要はありません。パッケージ名はインポート時のデフォルト名に過ぎず、すべてのソースコードで一意である必要はありません。また、まれに衝突した場合、インポートするパッケージはローカルで使用する別の名前を選ぶことができます。いずれにしても、インポート時のファイル名でどのパッケージが使われているかが決まるため、混乱することはまずありません。

もうひとつの慣例は、パッケージ名はそのソースディレクトリのベースネームであるということです。`src/encoding/base64`にあるパッケージは、`"encoding/base64"`としてインポートされますが、名前は`base64`であり、`encoding_base64`でも`encodingBase64`でもありません。

パッケージのインポーターはその名前を使ってパッケージの内容を参照するので、パッケージ内でエクスポートされた名前はその事実を利用して繰り返しを避けることができます。(`import` .表記は、テスト対象のパッケージの外で実行しなければならないテストを簡略化することができますが、避けたほうがいいでしょう)。例えば、`bufio`パッケージのバッファードリーダータイプは、`BufReader`ではなく`Reader`と呼ばれていますが、これはユーザーがそれを`bufio.Reader`と見るからであり、これは明確で簡潔な名前です。さらに，インポートされた実体は常にパッケージ名で表されるので，`bufio.Reader`は`io.Reader`と衝突することはありません．同様に、`ring.Ring`の新しいインスタンスを作成する関数（これはGoにおけるコンストラクタの定義です）は、通常は`NewRing`と呼ばれますが、`Ring`はパッケージがエクスポートする唯一の型であり、パッケージは`ring`と呼ばれるので、単に`New`と呼ばれ、パッケージのクライアントは`ring.New`として見ることができます。パッケージのクライアントには `ring.New` と表示されます。パッケージの構造を参考にして、良い名前を選んでください。

もう一つの短い例は、`once.Do`です。`once.Do(setup)`はよく読めますし、`once.DoOrWaitUntilDone(setup)`と書いても改善されません。長い名前は自動的に読みやすくなるわけではありません。役に立つドキュメントコメントの方が、余分に長い名前よりも価値がある場合があります。


### Getters

Go はゲッターとセッターを自動的にはサポートしません。自分でゲッターやセッターを用意することは悪いことではありませんし、そうすることが適切な場合もありますが、ゲッターの名前に `Get` を入れることは慣用的でも必要でもありません。`owner`（小文字、unexported）というフィールドがある場合、ゲッターメソッドの名前は `GetOwner` ではなく `Owner`（大文字、exported）でなければなりません。エクスポート時に大文字の名前を使用することで、フィールドとメソッドを区別するためのフックとなります。セッター関数が必要な場合は、おそらく `SetOwner` と呼ばれるでしょう。どちらの名前も実際にはよく読めます。

```go
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
```

### Interface names

慣習的に、ワンメソッドのインターフェースは、メソッド名に-erの接尾辞をつけるか、または同様の修飾をしてエージェント名詞を構成して命名されます。
 例えば、`Reader`, `Writer`, `Formatter`, `CloseNotifier`などです。

このような名前は数多くありますが、これらの名前とそれらが捉える関数名を尊重することは生産的です。`Read`, `Write`, `Close`, `Flush`, `String` などは正規のシグネチャと意味を持っています。混乱を避けるために、同じ署名と意味を持たない限り、自分のメソッドにこれらの名前を付けないでください。逆に、よく知られた型のメソッドと同じ意味を持つメソッドを自分の型が実装している場合は、同じ名前とシグネチャを与えます。文字列変換メソッドを `ToString` ではなく `String` と呼びます。

### MixedCaps

最後に、Goでは、マルチワードの名前を書くときには、アンダースコアではなく、`MixedCaps`または`mixedCaps`を使うのが慣例となっています。

## セミコロン


C言語と同様に、Goの形式文法では文の終わりにセミコロンを使用しますが、C言語とは異なり、セミコロンはソースには表示されません。その代わり、レキサーは簡単なルールを使って、スキャン時にセミコロンを自動的に挿入するので、入力テキストにはほとんどセミコロンが含まれません。

そのルールとは次のようなものです。改行前の最後のトークンが、識別子（`int`や`float64`など）、数値や文字列定数などの基本的なリテラル、または以下のトークンのいずれかである場合

```go
break continue fallthrough return ++ -- ) }
```

の場合、レキサーは常にそのトークンの後にセミコロンを挿入します。これは要約すると、「文を終わらせる可能性のあるトークンの後に改行が来たら、セミコロンを挿入する」ということです。

セミコロンは閉じ括弧の直前でも省略できるので、次のような文は

```go
    go func() { for { dst <- <-src } }()
```

はセミコロンを必要としません。慣用的なGoプログラムでは、セミコロンは、初期化子、条件、継続の各要素を分けるために、`for`ループ節などの場所でのみ使用されます。セミコロンは、一行にある複数のステートメントを分離するためにも必要ですが、そのようにコードを書く必要があります。

セミコロンの挿入規則の結果として、制御構造（`if`、`for`、`switch`、`select`）の開始波括弧を次の行に置くことができません。これは、制御構造の開始波括弧（`if`、`for`、`switch`、`select`）を次の行に置いてはいけないということです。次のように書いてください。

```go
if i < f() {
    g()
}
```

こうじゃない

```go
if i < f()  // wrong!
{           // wrong!
    g()
}
```


## 制御構造

Goの制御構造はC言語のそれと関連していますが、重要な点で異なります。`do`や`while`のループはなく、わずかに一般化された`for`があるだけです。
 また、`switch` はより柔軟です。
 `if` と `switch` は、`for` のようなオプションの初期化文を受け入れます。
 `break` と `continue` ステートメントには、break やcontinue を識別するためのオプションのラベルを指定します。
 また、タイプスイッチや多方向通信マルチプレクサである`select`などの新しい制御構造もあります。構文も若干異なり、括弧はなく、ボディは常にブレースで区切られています。

### If

Goではシンプルな`if`は次のようになります。

```go
if x > 0 {
    return y
}
```

中括弧を必須とすることで、単純な `if` 文を複数行に渡って書くことを推奨しています。特に、本文に `return` や `break` などの制御文が含まれている場合には、そのように書くのが良いスタイルです。

`if` や `switch` は初期化文を受け付けるので、ローカル変数を設定するために使われることがよくあります。


```go
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
```

Goのライブラリでは、`if`文が次の文に流れない場合、つまり、本体が`break`、`continue`、`goto`、`return`で終わっている場合には、不要な`else`が省略されています。

```go
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
```

これは、コードが一連のエラー条件に対してガードしなければならない、よくある状況の例です。このコードは、正常な制御の流れがページを流れていき、エラーケースが発生するたびにそれを排除していく場合によく読まれます。エラーケースは `return` ステートメントで終わることが多いので、結果として得られるコードには `else` ステートメントは必要ありません。

```go
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
```

### 再宣言と再配置

余談です。前節の最後の例では、`:=`という短い宣言形式がどのように機能するかを詳しく説明しています。os.Open`を呼び出す宣言は次のようになります。

```go
f, err := os.Open(name)
```

このステートメントでは、2つの変数 `f` と `err` を宣言しています。数行後、`f.Stat`への呼び出しは次のようになります。

```go
d, err := f.Stat()
```

と書かれていて、あたかも`d`と`err`を宣言しているように見えます。しかし、`err`は両方のステートメントに現れていることに注意してください。この重複は合法です。`err`は最初のステートメントで宣言されますが、2番目のステートメントで再割り当てされるだけです。つまり、`f.Stat`の呼び出しは、上で宣言された既存の `err` 変数を使用して、新しい値を与えるだけなのです。

`:=`の宣言では、変数`v`がすでに宣言されていても、以下の条件で出現させることができます。

- この宣言が、既存の `v` の宣言と同じスコープ内にあること（`v` が外部のスコープで既に宣言されている場合は、宣言によって新しい変数§が作成されます）。
- 初期化で対応する値が `v` に割り当て可能であること。
- 宣言によって作成される他の変数が少なくとも1つある。

この変わったプロパティは純粋なプラグマティズムで、例えば、長い `if-else` チェーンの中で単一の `err` 値を簡単に使用することができます。よく使われているのを見かけると思います。

§ Goでは、関数のパラメータと戻り値のスコープは、関数本体を囲む中括弧の外側に語彙的に現れていても、関数本体と同じであることをここで指摘しておきます。



### For

Goの`for`ループはC言語のものと似ていますが、同じではありません。これは`for`と`while`を統合したもので、`do-while`はありません。3つの形式があり、そのうち1つだけがセミコロンを持っています。


```go
// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
```

短く宣言することで、ループの中ですぐにインデックス変数を宣言することができます。

```go
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
```

配列、スライス、文字列、マップをループさせたり、チャネルから読み込んだりする場合は、`range`句でループを管理することができます。

```go
for key, value := range oldMap {
    newMap[key] = value
}
```

範囲内の最初の項目（キーまたはインデックス）だけが必要な場合は、2番目の項目を削除します。

```go
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
```

範囲内の2番目の項目（値）だけが必要な場合は、空白の識別子であるアンダースコアを使用して、1番目の項目を破棄します。

```go
sum := 0
for _, value := range array {
    sum += value
}
```

空白の識別子は、[後のセクション](https://golang.org/doc/effective_go#blank)で説明するように、多くの用途があります。

文字列の場合は、UTF-8を解析して個々のUnicodeコードポイントを分割するなど、`range`がより多くの仕事をしてくれます。誤ったエンコーディングは1バイトを消費し、置換ルーンU+FFFDを生成します。(名前(および関連する組み込み型) `rune` は、単一の Unicode コードポイントに対する Go の用語です。詳細は[言語仕様](https://golang.org/ref/spec#Rune_literals)を参照してください)。ループは

```go
for pos, char := range "日本\x80語" { // \x80 is an illegal UTF-8 encoding
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
```

による表示は

```go
character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
```

最後に、Goにはコンマ演算子がなく、`++`と`--`は式ではなく文です。したがって、複数の変数を `for` で実行したい場合は、並列割り当てを使用する必要があります (ただし、`++` と `--` は除外されます)。

```go
// Reverse a
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
```

### Switch

Goの`switch`はCのものよりも一般的です。式は定数や整数である必要はなく、ケースはマッチするものが見つかるまで上から下へと評価され、`switch`に式がない場合は`true`に切り替わります。したがって、`if`-`else`-`if`-`else`の連鎖を`switch`として書くことが可能であり、慣用的でもあります。

```go
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
```

自動的にフォールスルーことはありませんが、ケースはコンマで区切られたリストで提示することができます。

```go
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
        return true
    }
    return false
}
```

Goでは、他のC言語のように一般的ではありませんが、`break`文を使って`switch`を早期に終了させることができます。しかし、スイッチではなく、周囲のループから抜け出す必要がある場合もあります。Goでは、ループにラベルを付けて、そのラベルに向かって「break」することで実現できます。この例では、両方の使い方を示しています。

```go
Loop:
	for n := 0; n < len(src); n += size {
		switch {
		case src[n] < sizeOne:
			if validateOnly {
				break
			}
			size = 1
			update(src[n])

		case src[n] < sizeTwo:
			if n+1 >= len(src) {
				err = errShortInput
				break Loop
			}
			if validateOnly {
				break
			}
			size = 2
			update(src[n] + src[n+1]<<shift)
		}
	}
```

もちろん、`continue`文にもオプションのラベルを付けることができますが、これはループにのみ適用されます。

このセクションの最後に、2つの`switch`文を使ったバイトスライスの比較ルーチンを紹介します。

```go
// Compareは、2つのバイトスライスを辞書的に比較する整数を返します。
// 結果は、a == bの場合は0、a < bの場合は-1、a > bの場合は+1となります。
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    switch {
    case len(a) > len(b):
        return 1
    case len(a) < len(b):
        return -1
    }
    return 0
}
```


### タイプスイッチ

インターフェース変数の動的な型を知るためにスイッチを使うこともできます。このようなタイプスイッチは、キーワード `type` を括弧の中に入れたタイプアサーションの構文を使用します。スイッチが式の中で変数を宣言した場合、その変数は各節で対応する型を持つことになります。このような場合、名前を再利用することも慣用的で、事実上、同じ名前でタイプの異なる新しい変数を各ケースで宣言することになります。

```go
var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("unexpected type %T\n", t)     // %T prints whatever type t has
case bool:
    fmt.Printf("boolean %t\n", t)             // t has type bool
case int:
    fmt.Printf("integer %d\n", t)             // t has type int
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) // t has type *bool
case *int:
    fmt.Printf("pointer to integer %d\n", *t) // t has type *int
}
```

## 関数
### 複数の戻り値

Goの珍しい機能のひとつに、関数やメソッドが複数の値を返せることがあります。この形式は、Cプログラムの不器用なイディオムを改善するために使用することができます。例えば、`EOF`に対する`-1`のような帯域内エラーの戻り値や、アドレスで渡された引数の修正です。

Cでは、書き込みエラーは負のカウントで通知され、エラーコードは揮発性の場所に隠されます。Goでは、`Write`はカウントとエラーを返すことができます。「はい、何バイトか書きましたが、デバイスがいっぱいになってしまったので、全部は書きませんでした」。パッケージ `os` のファイルに対する `Write` メソッドのシグネチャは次のとおりです。

```go
func (file *File) Write(b []byte) (n int, err error)
```

ドキュメントに書かれているように、書き込まれたバイト数を返し、`n` `!=` `len(b)` のときには非nilの `エラー` を返します。これは一般的なスタイルです。その他の例については、エラー処理のセクションを参照してください。

同様の方法で，参照パラメータを模擬した戻り値へのポインタを渡す必要はありません．以下は，バイトスライスのある位置から数値を取り出し，その数値と次の位置を返す，単純な関数です．

```go
func nextInt(b []byte, i int) (int, int) {
    for ; i < len(b) && !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i < len(b) && isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
```

これを使って、入力スライス `b` の中の数字をスキャンすると、次のようになります。

```go
    for i := 0; i < len(b); {
        x, i = nextInt(b, i)
        fmt.Println(x)
    }
```


### 名前付きの結果パラメータ

Go 関数の戻り値または結果の「パラメータ」には名前を付けて、入力パラメータと同様に通常の変数として使用することができます。関数が引数なしで `return` 文を実行した場合、結果パラメーターの現在の値が戻り値として使用されます。

名前は必須ではありませんが、コードを短く、明確にすることができます。これはドキュメントです。`nextInt`の結果に名前を付ければ、どの戻り値の`int`がどれなのかが明らかになります。

```go
func nextInt(b []byte, pos int) (value, nextPos int) {
```

名前付きの結果は初期化され、飾り気のない戻り値に結びついているので、明確にするだけでなく単純化することもできます。以下は、名前付き結果をうまく使った `io.ReadFull` のバージョンです:

```go
func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
```

### Defer

Goの`defer`文は、`defer`を実行する関数が戻る直前に、関数呼び出し（遅延関数）を実行するようにスケジュールします。これは変わった方法ですが、関数がどのような経路で戻ってきても解放しなければならないリソースなどの状況に対処するための効果的な方法です。典型的な例としては、mutexのロック解除やファイルのクローズなどが挙げられます。

```go
// Contentsはファイルの内容を文字列で返します。
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    // defer f.Close()  // f.Closeは終了時に実行されます。

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
```

`Close`のような関数の呼び出しを延期することには、2つの利点があります。まず、ファイルを閉じることを忘れないことが保証されます。これは、後に関数を編集して新しいリターンパスを追加した場合に陥りやすいミスです。2つ目は、closeがopenの近くに配置されているということで、関数の最後に配置するよりもはるかにわかりやすいということです。

遅延された関数の引数（関数がメソッドの場合はレシーバーも含む）は、呼び出しが実行されたときではなく、遅延が実行されたときに評価されます。これは、関数の実行中に変数の値が変化する心配がないだけでなく、1つの遅延呼び出しサイトで複数の関数の実行を遅延させることができることを意味します。くだらない例を挙げてみましょう。

```go
for i := 0; i < 5; i++ {
    defer fmt.Printf("%d ", i)
}
```

遅延関数はLIFO順に実行されるので、このコードでは関数が戻ってきたときに`4 3 2 1 0`が出力されることになります。もっと妥当な例としては、プログラム中の関数実行をトレースする簡単な方法があります。次のような簡単なトレースルーチンをいくつか書いてみましょう。


```go
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// Use them like this:
func a() {
    trace("a")
    defer untrace("a")
    // do something....
}
```

遅延関数への引数は `defer` が実行されたときに評価されるという事実を利用することで、より良い結果を得ることができます。トレースルーチンは、アントレースルーチンへの引数を設定することができます。この例では

```go
func trace(s string) string {
    fmt.Println("entering:", s)
    return s
}

func un(s string) {
    fmt.Println("leaving:", s)
}

func a() {
    defer un(trace("a"))
    fmt.Println("in a")
}

func b() {
    defer un(trace("b"))
    fmt.Println("in b")
    a()
}

func main() {
    b()
}
```

prints

```go
entering: b
in b
entering: a
in a
leaving: a
leaving: b
```

他の言語でブロックレベルのリソース管理に慣れているプログラマにとっては、 `defer` は奇妙に思えるかもしれませんが、その最も興味深く強力なアプリケーションは、 まさにブロックベースではなく、関数ベースであるという事実から来ています。`panic`と`recover`のセクションでは、その可能性の別の例を見てみましょう。

## データ
### `new`によるアロケーション

Goには、組み込み関数の`new`と`make`という2つのアロケーションプリミティブがあります。これらはそれぞれ異なる機能を持ち、異なる型に適用されるので、混乱するかもしれませんが、ルールは簡単です。まず`new`について説明します。これはメモリを確保する組み込み関数ですが、他の言語の同名の関数とは異なり、メモリを初期化せず、ゼロにするだけです。つまり、`new(T)`は、`T`型の新しいアイテム用にゼロのストレージを割り当て、そのアドレス（`*T`型の値）を返します。Goの用語では、`T`型の新しく割り当てられたゼロの値へのポインタを返します。

`new`が返すメモリはゼロになっているので、データ構造を設計するときに、各型のゼロ値がさらなる初期化なしに使用できるように手配すると便利です。これは、データ構造のユーザが `new` を使ってデータ構造を作成し、すぐに作業を開始できることを意味します。例えば、`bytes.Buffer`のドキュメントには、"`Buffer`のゼロ値は、すぐに使える空のバッファである "と記載されています。同様に、`sync.Mutex` には、明示的なコンストラクタや `Init` メソッドはありません。代わりに、`sync.Mutex` のゼロ値は、ロックされていないミューテックスであると定義されます。

zero-value-is-usefulプロパティは、過渡的に動作します。以下の型宣言を考えてみましょう。

```go
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
```

また、`SyncedBuffer`型の値は、割り当てや宣言だけですぐに使用できます。次のスニペットでは、`p`と`v`の両方が、さらなるアレンジなしに正しく動作します。

```go
p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
```


### コンストラクタと複合リテラル

パッケージ `os` から派生したこの例のように、ゼロ値では十分ではなく、初期化コンストラクタが必要な場合があります。

```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
```

そこにはたくさんの決まり文句があります。複合リテラルとは、評価されるたびに新しいインスタンスを生成する式のことで、これを単純化することができます。

```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &f
}
```

C言語とは異なり、ローカル変数のアドレスを返すことは全く問題ありません。変数に関連付けられたストレージは、関数が戻った後も存続します。実際、複合リテラルのアドレスを取得すると、評価されるたびに新しいインスタンスが割り当てられるので、最後の2行を組み合わせることができます。

```go
    return &File{fd, name, nil, 0}
```

複合リテラルのフィールドは順番に並べられ、すべて存在しなければなりません。しかし、要素をfield`:`valueのペアとして明示的にラベル付けすることで、初期化子はどのような順序でも現れ、欠けているものはそれぞれのゼロ値として残されます。このようにすると、

```go
    return &File{fd: fd, name: name}
```

限定的なケースとして，複合リテラルにフィールドがまったく含まれていない場合，その型の値はゼロになります。`new(File)` と `&File{}` という表現は同等です。

複合リテラルは，配列，スライス，マップに対しても作成することができ，フィールドラベルは適宜インデックスやマップのキーになります．これらの例では，初期化は，`Enone`，`Eio`，`Einval`の値が異なっていても，動作します．

```go
a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
```


### アロケーションと `make` の関係

アロケーションの話に戻ります。組み込み関数 `make(T, args)` は `new(T)` とは異なる目的を持っています．スライス，マップ，チャンネルのみを作成し，`T`型（`*T`型ではない）の初期化された（ゼロになっていない）値を返します．このように区別する理由は，これらの3つの型が，使用前に初期化されなければならないデータ構造への参照を表向きに表しているからです．例えば，スライスは，データ（配列内）へのポインタ，長さ，容量の3つの項目を含む記述子であり，これらの項目が初期化されるまで，スライスは`nil`となります．スライス，マップ，チャンネルについては，`make`によって内部のデータ構造が初期化され，値が使用できるようになります．例えば，以下のようになります．

```go
make([]int, 10, 100)
```

これは，100個のintの配列を確保し，配列の最初の10個の要素を指す長さ10，容量100のスライス構造体を作成します（スライスを作成する際には，容量を省略することができます。(スライスを作成する際には，容量を省略することができます。詳しくはスライスのセクションをご覧ください。) 一方，`new([]int)` は，新しく確保され，ゼロになったスライス構造体へのポインタ，すなわち，`nil` のスライス値へのポインタを返します．

これらの例は、`new`と`make`の違いを示しています。


```go
var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
```

`make`は、マップ、スライス、チャンネルにのみ適用され、ポインタを返さないことに注意してください。明示的なポインタを得るためには、`new`で割り当てるか、明示的に変数のアドレスを取得してください。

### 配列

配列は、メモリの詳細なレイアウトを計画する際に便利で、時には割り当てを回避するのに役立つこともありますが、主に次のセクションで扱うスライスのための構成要素です。そのための基礎知識として、ここでは配列についていくつか説明します。

GoとCでは、配列の動作に大きな違いがあります。

- 配列は値です。ある配列を別の配列に代入すると、すべての要素がコピーされます。
- 特に、関数に配列を渡した場合、関数は配列へのポインタではなく、配列のコピーを受け取ります。
- 配列のサイズはその型の一部である。10]int`と`[20]int`はそれぞれ異なる型です。

C言語のような動作と効率性を求める場合は，配列へのポインタを渡すことができます。

```go
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // 明示的な address-of 演算子に注意してください。
```

しかし、このスタイルでもイディオム的なGoではありません。代わりにスライスを使いましょう。


### スライス

スライスは、配列をラップして、データのシーケンスに対するより一般的で強力かつ便利なインターフェースを提供します。変換行列のような明示的な次元を持つアイテムを除き、Goのほとんどの配列プログラミングは、単純な配列ではなくスライスを使って行われます。

スライスは、基礎となる配列への参照を保持しており、あるスライスを別のスライスに割り当てると、両方とも同じ配列を参照します。関数がスライスの引数を取る場合、スライスの要素に加えた変更は呼び出し元から見えることになり、基礎となる配列へのポインタを渡すのと同様になります。したがって、`Read`関数は、ポインタとカウントではなく、スライス引数を受け取ることができます。スライス内の長さは、読み込むデータ量の上限を設定します。パッケージ `os` の `File` 型の `Read` メソッドのシグネチャを以下に示します．

```go
func (f *File) Read(buf []byte) (n int, err error)
```

このメソッドは，読み込んだバイト数と，エラーがあればエラー値を返します。大きなバッファ `buf` の最初の 32 バイトを読み込むには、バッファをスライスします。

```go
    n, err := f.Read(buf[0:32])
```

このようなスライスは一般的で効率的です。実際、効率の良さはさておき、次のスニペットでもバッファの最初の32バイトを読み取ることができます。


```go
    var n int
    var err error
    for i := 0; i < 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.
        n += nbytes
        if nbytes == 0 || e != nil {
            err = e
            break
        }
    }
```

スライスの長さは，基礎となる配列の制限内に収まる限り，変更することができ，それを自分自身のスライスに割り当てるだけです．組み込み関数 `cap` でアクセスできるスライスの容量は、そのスライスが想定できる最大の長さを報告します。ここでは，スライスにデータを追加する関数を示します。データが容量を超えた場合には、スライスが再割り当てされます。結果として、スライスが返されます。この関数は、`len`と`cap`が`nil`のスライスに適用されたときに合法であることを利用して、0を返します。

```go
func Append(slice, data []byte) []byte {
    l := len(slice)
    if l + len(data) > cap(slice) {  // reallocate
        // Allocate double what's needed, for future growth.
        newSlice := make([]byte, (l+len(data))*2)
        // The copy function is predeclared and works for any slice type.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    copy(slice[l:], data)
    return slice
}
```

なぜなら、`Append` は `slice` の要素を変更することができますが、スライス自体 (ポインタ、長さ、容量を保持するランタイムデータ構造) は値で渡されるからです。

スライスに追記するというアイデアは非常に便利なので、組み込み関数の `append` で表現されています。しかし、この関数の設計を理解するには、もう少し情報が必要なので、後で説明します。

### 二次元のスライス

Goの配列やスライスは一次元です。2次元の配列やスライスに相当するものを作るには、次のように配列-of-配列やスライス-of-スライスを定義する必要があります。

```go
type Transform [3][3]float64  // 3×3の配列で、まさに配列の配列です。
type LinesOfText [][]byte     // バイトスライスのスライスです。
```

スライスは可変長なので、内側のスライスをそれぞれ異なる長さにすることが可能です。これはよくある状況で、例えば `LinesOfText` の例では、各行が独立した長さを持つことになります。

```go
text := LinesOfText{
	[]byte("Now is the time"),
	[]byte("for all good gophers"),
	[]byte("to bring some fun to the party."),
}
```

例えば、ピクセルのスキャンラインを処理する際に、2Dスライスを割り当てる必要がある場合があります。これを実現するには2つの方法があります。1つは、各スライスを個別に割り当てる方法、もう1つは、1つの配列を割り当てて、その中に各スライスを入れる方法です。どちらを採用するかは、アプリケーションによって異なります。スライスが大きくなったり小さくなったりする可能性がある場合は，次の行を上書きしないように独立して割り当てるべきですが，そうでない場合は，単一の割り当てでオブジェクトを構築する方が効率的です。参考までに、この2つの方法の概要を説明します。まず、1行ずつの場合。

```go
// トップレベルのスライスを割り当てます。
picture := make([][]uint8, YSize) // yの単位につき、1列。
// 行をループして、各行にスライスを割り当てます。
for i := range picture {
	picture[i] = make([]uint8, XSize)
}
```

そして、今では1つの配分として、線状にスライスされています。

```go
// 先ほどと同じように、トップレベルのスライスを割り当てます。
picture := make([][]uint8, YSize) // yの単位で1列。
// すべてのピクセルを保持するために、1つの大きなスライスを割り当てます。
pixels := make([]uint8, XSize*YSize) // ピクチャが[][]uint8であるにもかかわらず、[]uint8型を持つ。
// 各列をループさせ、残りのピクセルスライスの前から各列をスライスします。
for i := range picture {
	picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
```

### Maps

マップは、ある型の値（キー）と別の型の値（要素または値）を関連付ける、便利で強力な組み込みデータ構造です。キーには、整数、浮動小数点数、複素数、文字列、ポインター、インターフェース（動的型が等式をサポートしている場合）、構造体、配列など、等式演算子が定義されている任意の型を使用できます。スライスには等値性が定義されていないため、マップのキーとしては使用できません。スライスと同様に、マップは基礎となるデータ構造への参照を保持します。マップの内容を変更する関数にマップを渡した場合、その変更は呼び出し元にも表示されます。

マップは、コロンで区切られたキーと値のペアを持つ通常の複合リテラル構文を使って構築することができるので、初期化時に簡単に構築することができます。

```go
var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
```

マップの値を割り当てたり取得したりする構文は、インデックスが整数である必要がないことを除けば、配列やスライスの場合と同じです。


```go
offset := timeZone["EST"]
```

マップに存在しないキーでマップの値を取得しようとすると、マップのエントリの型に応じたゼロの値が返されます。例えば，マップに整数が含まれている場合，存在しないキーを検索すると，`0`が返されます。セットは値の型が `bool` のマップとして実装できます。マップのエントリを `true` に設定して値をセットに入れ、単純なインデックスでそれをテストします。

```go
attended := map[string]bool{
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // マップにpersonがない場合はfalseになります。
    fmt.Println(person, "was at the meeting")
}
```

時には、エントリの欠落とゼロの値を区別する必要があります。`"UTC"`のエントリがあるのか、それともマップに全くないので0なのか。多重割り当ての形で区別することができます。

```go
var seconds int
var ok bool
seconds, ok = timeZone[tz]
```

明らかな理由により、これは「コンマok」イディオムと呼ばれます。この例では、もし `tz` があれば、`seconds` が適切に設定され、`ok` が真となり、そうでなければ、`seconds` はゼロに設定され、`ok` は偽となります。これをエラーレポートとともに出力する関数があります。

```go
func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
}
```

実際の値を気にせずにマップ内の存在をテストするには、通常の値を表す変数の代わりに空白の識別子（`_`）を使用することができます。


```go
_, present := timeZone[tz]
```

マップのエントリを削除するには、`delete`という組み込み関数を使います。この関数の引数は、マップと削除するキーです。そのキーがすでにマップに存在しない場合でも、この操作は安全です。

```go
delete(timeZone, "PDT")  // Now on Standard Time
```

### Printing

Goのフォーマット表示は、C言語の `printf` ファミリーに似たスタイルを採用していますが、より豊富で一般的です。関数は `fmt` パッケージに含まれており、`fmt.Printf`, `fmt.Fprintf`, `fmt.Sprintf` などのように大文字の名前が付いています。文字列関数（`Sprintf`など）は，与えられたバッファを埋めるのではなく，文字列を返します。

フォーマット文字列を用意する必要はありません。`Printf`, `Fprintf`, `Sprintf` のそれぞれに対して、例えば `Print` と `Println` のような別の関数のペアがあります。これらの関数はフォーマット文字列を受け取りませんが、代わりに各引数に対してデフォルトのフォーマットを生成します。また、`Println`バージョンでは、引数間に空白を挿入し、出力に改行を追加しますが、`Print`バージョンでは、どちらの側のオペランドも文字列でない場合にのみ空白を追加します。この例では、各行が同じ出力を生成します。

```go
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
```

書式付き表示関数 `fmt.Fprint` とその仲間たちは、`io.Writer` インターフェースを実装したオブジェクトを第一引数にとります。

まず、`%d`のような数値フォーマットでは、符号化やサイズのフラグを取りません。

```go
var x uint64 = 1<<64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
```

この表示は以下のようになる。

```sh
18446744073709551615 ffffffffffffffff; -1 -1
```

整数を10進数に変換するなど、デフォルトの変換が必要な場合は、`%v`(for "value")というキャッチオールフォーマットを使用できます。結果は、`Print`や`Println`が生成するものとまったく同じです。さらに、このフォーマットは、配列、スライス、構造体、マップなど、あらゆる値を表示できます。以下は、前のセクションで定義したタイムゾーンマップのprint文です。

```go
fmt.Printf("%v\n", timeZone)  // or just fmt.Println(timeZone)
```

以下が出力されます。

```sh
map[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0]
```

マップの場合、`Printf`とその仲間たちは、キーによって出力を辞書的にソートします。

構造体を印刷する場合、修正されたフォーマット `%+v` は構造体のフィールドに名前を付け、任意の値に対しては代替フォーマット `%#v` が完全な Go 構文で値を印刷します。

```go
type T struct {
    a int
    b float64
    c string
}
t := &T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
```

以下を表示します。

```sh
&{7 -2.35 abc   def}
&{a:7 b:-2.35 c:abc     def}
&main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string]int{"CST":-21600, "EST":-18000, "MST":-25200, "PST":-28800, "UTC":0}
```

(この引用符付き文字列のフォーマットは、`string` または `[]byte` 型の値に適用される場合、`%q` でも利用できます。代替フォーマットである `%#q` では、可能な限りバッククォートを使用します。(`%q` フォーマットは整数とルーンにも適用され、シングルクォートのルーン定数を生成します)。また、`%x` は整数だけでなく、文字列、バイト配列、バイトスライスにも対応しており、長い16進数の文字列を生成し、フォーマットにスペースを入れると (`% x`) バイト間にスペースが入ります。

もうひとつの便利なフォーマットは `%T` で、これは値の型を表示します。


```go
fmt.Printf("%T\n", timeZone)
```

これは以下を表示する。

```sh
map[string]int
```

カスタムタイプのデフォルトフォーマットを制御したい場合、必要なのはそのタイプに `String() string` というシグネチャを持つメソッドを定義することだけです。単純な型である `T` の場合は、次のようになります。

```go
func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
```

の形式で表示することができます。

```sh
7/-2.35/"abc\tdef"
```

(この例ではポインタを使用していますが、これは構造体型の場合にはポインタの方が効率的で慣用的だからです。この例ではポインタを使用していますが、これは構造体型ではより効率的で慣用的だからです。詳細は後述の [ポインタ vs. 値のレシーバ](https://golang.org/doc/effective_go#pointers_vs_values) のセクションを参照してください。）

この `String` メソッドは `Sprintf` を呼び出すことができます。これは print ルーチンが完全にリエントラントで、このようにラップできるからです。ただし、この方法について理解しておくべき重要な点が 1 つあります。それは、`Sprintf` を呼び出して `String` メソッドを構築し、String メソッドの中に無限に再帰するような方法を取らないことです。これは、`Sprintf` の呼び出しが、レシーバを直接文字列として出力しようとし、その結果、このメソッドが再び呼び出される場合に起こります。この例が示すように、これはよくある簡単な間違いです。

```go
type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", m) // Error: will recur forever.
}
```

これを修正するのも簡単です。引数を、このメソッドを持たない基本的な文字列型に変換します。

```go
type MyString string
func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", string(m)) // OK: note conversion.
}
```

[初期化セクション](https://golang.org/doc/effective_go#initialization)では、この再帰を避けるための別のテクニックを紹介します。

もう一つの表示技術は、表示ルーチンの引数を別の表示ルーチンに直接渡すことです。Printf`のシグネチャでは、最終引数に`...interface{}`という型を使用して、フォーマットの後に任意の数のパラメータ（任意の型）を表示できることを指定しています。

```go
func Printf(format string, v ...interface{}) (n int, err error) {
```

関数 `Printf` の中では、`v` は `[]interface{}` 型の変数のように振る舞いますが、他の可変長の関数に渡した場合は、通常の引数リストのように振る舞います。ここでは，上記で使用した関数 `log.Println` の実装を示します．この関数は、引数を直接 `fmt.Sprintln` に渡して、実際の書式設定を行います。


```go
// Printlnは、fmt.Printlnの要領で標準ロガーに印字します。
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)
}
```

`Sprintln` のネストした呼び出しの中で `v` の後に `...` と書いているのは、コンパイラに `v` を引数のリストとして扱うように指示するためです。そうしないと、`v` を単一のスライス引数として渡してしまいます。

ここで説明した以外にも、印刷には様々な機能があります。詳しくは，パッケージ `fmt` の `godoc` ドキュメントを参照してください．

ところで，`...`のパラメータは，特定の型にすることができます．例えば，整数のリストの中から最小のものを選ぶmin関数の場合，`...int`となります．

```go
func Min(a ...int) int {
    min := int(^uint(0) >> 1)  // largest int
    for _, i := range a {
        if i < min {
            min = i
        }
    }
    return min
}
```


### Append

これで、組み込み関数 `append` の設計を説明するのに必要な、欠けていた部分ができました。この `append` のシグネチャは、上で説明したカスタムの `Append` 関数とは異なります。図式的には次のようになります。

```go
func append(slice []T, elements ...T) []T
```

ここで、Tは任意の型を表すプレースホルダーです。実際には、型 `T` が呼び出し側で決定されるような関数を Go で書くことはできません。これが `append` が組み込まれている理由で、コンパイラのサポートが必要です。

`append`が行うことは、要素をスライスの最後に追加し、その結果を返すことです。結果を返す必要があるのは、手書きの `Append` と同様に、基礎となる配列が変更される可能性があるからです。次の簡単な例

```go
x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
```

は `[1 2 3 4 5 6]` を出力します。つまり、`append` は `Printf` と同じように、任意の数の引数を集めて動作します。

しかし、`Append`が行うことを実行して、スライスにスライスを追加したいとしたらどうでしょう? 簡単です。上の `Output` の呼び出しと同じように、呼び出しサイトで `...` を使用します。このスニペットは上のものと同じ出力をします。

```go
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
```

この `...` がないと、型が間違っているのでコンパイルできません。`y` は `int` 型ではありません。

## 初期化

CやC++の初期化と表面的にはあまり変わらないように見えますが、Goの初期化はより強力です。初期化中に複雑な構造を構築することができ、初期化されたオブジェクト間の順序問題は、異なるパッケージ間であっても、正しく処理されます。


### 定数

Goの定数はただの定数です。定数はコンパイル時に作成され、関数内でローカルとして定義されている場合でも、数字、文字（ルーン）、文字列、ブーリアンのみとなります。コンパイル時の制限のため、定数を定義する式は、コンパイラで評価可能な定数式でなければなりません。例えば、`1<<3`は定数式ですが、`math.Sin(math.Pi/4)`は定数式ではありません。`math.Sin`の関数呼び出しは実行時に行われる必要があるからです。

Goでは、列挙型の定数は `iota` という列挙子を使って作成します。`iota` は式の一部にすることができ、式は暗黙的に繰り返すことができるので、複雑な値のセットを簡単に作ることができます。

```go
type ByteSize float64

const (
    _           = iota // 空白の識別子に割り当てて最初の値を無視する
    KB ByteSize = 1 << (10 * iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
```

任意のユーザ定義型に `String` などのメソッドを付加することで、任意の値を印刷時に自動的に整形することができます。構造体に適用されることが多いのですが、このテクニックは `ByteSize` のような浮動小数点型などのスカラ型にも有効です。

```go
func (b ByteSize) String() string {
    switch {
    case b >= YB:
        return fmt.Sprintf("%.2fYB", b/YB)
    case b >= ZB:
        return fmt.Sprintf("%.2fZB", b/ZB)
    case b >= EB:
        return fmt.Sprintf("%.2fEB", b/EB)
    case b >= PB:
        return fmt.Sprintf("%.2fPB", b/PB)
    case b >= TB:
        return fmt.Sprintf("%.2fTB", b/TB)
    case b >= GB:
        return fmt.Sprintf("%.2fGB", b/GB)
    case b >= MB:
        return fmt.Sprintf("%.2fMB", b/MB)
    case b >= KB:
        return fmt.Sprintf("%.2fKB", b/KB)
    }
    return fmt.Sprintf("%.2fB", b)
}
```

式 `YB` は `1.00YB` と表示されますが，`ByteSize(1e13)` は `9.09TB` と表示されます．

ここで `ByteSize` の `String` メソッドを実装するために `Sprintf` を使用していますが、これが安全 (無限に繰り返すことを避ける) なのは、変換のためではなく、文字列形式ではない `%f` で `Sprintf` を呼び出しているためです。`Sprintf` が `String` メソッドを呼び出すのは，文字列を必要とするときだけであり，`%f` は浮動小数点値を必要とします．

### 変数

変数は、定数と同様に初期化することができますが、初期化子は、実行時に計算される一般的な式にすることができます。

```go
var (
    home   = os.Getenv("HOME")
    user   = os.Getenv("USER")
    gopath = os.Getenv("GOPATH")
)
```


### init関数

最後に、各ソースファイルは独自の niladic `init` 関数を定義して、必要な状態をセットアップすることができます。(実際には、各ファイルは複数の`init`関数を持つことができます。) そして、finallyとは最後のことです。パッケージ内のすべての変数宣言が初期化子を評価した後に `init` が呼ばれ、それらはインポートされたすべてのパッケージが初期化された後に評価されます。

宣言として表現できない初期化の他に、`init`関数の一般的な使い方は、実際の実行が始まる前にプログラムの状態の正しさを検証したり修復したりすることです。


```go
func init() {
    if user == "" {
        log.Fatal("$USER not set")
    }
    if home == "" {
        home = "/home/" + user
    }
    if gopath == "" {
        gopath = home + "/go"
    }
    // gopath may be overridden by --gopath flag on command line.
    flag.StringVar(&gopath, "gopath", gopath, "override default GOPATH")
}
```

## メソッド
### ポインタと値の比較

`ByteSize`で見たように、メソッドは任意の名前の付いた型（ポインタやインターフェースを除く）に対して定義することができ、レシーバは構造体である必要はありません。

先ほどのスライスの説明では、`Append`という関数を書きました。これをスライスのメソッドとして定義することができます．そのためには、まず、メソッドをバインドできる名前付きの型を宣言し、メソッドのレシーバをその型の値にします。

```go
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // 本体は上記のAppend関数と全く同じです。
}
```

この場合でも、メソッドは更新されたスライスを返す必要があります。メソッドを再定義して、`ByteSlice`へのポインタをレシーバとして受け取り、メソッドが呼び出し元のスライスを上書きできるようにすることで、この不便さを解消できます。

```go
func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // Body as above, without the return.
    *p = slice
}
```

実際には、もっと良い方法があります。この関数を次のように修正して、標準的な `Write` メソッドのようにしてみましょう。

```go
func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // Again as above.
    *p = slice
    return len(data), nil
}
```

とすると、`*ByteSlice`という型は、標準的なインターフェイスである`io.Writer`を満たすことになり、これは便利なことです。例えば、1つにプリントすることができます。

```go
    var b ByteSlice
    fmt.Fprintf(&b, "This hour has %d days\n", 7)
```

ここでは，`*ByteSlice`のみが`io.Writer`を満たすので，`ByteSlice`のアドレスを渡しています．レシーバーのポインタと値に関するルールは、値のメソッドはポインタと値の両方に呼び出すことができますが、ポインタのメソッドはポインタにしか呼び出すことができません。

ポインタメソッドはレシーバを変更することができるので、このルールが発生します。値に対してポインタメソッドを呼び出すと、メソッドは値のコピーを受け取ることになるので、変更された部分は破棄されます。そのため、言語ではこのようなミスを禁止しています。しかし、便利な例外があります。値がアドレス可能な場合，言語はアドレス演算子を自動的に挿入することで，値に対してポインタメソッドを呼び出すという一般的なケースに対処します。今回の例では、変数 `b` がアドレス指定可能なので、その `Write` メソッドを `b.Write` だけで呼び出すことができます。コンパイラはこれを `(&b).Write` と書き換えてくれます。

ところで、バイトのスライスに対して `Write` を使用するというアイデアは、`bytes.Buffer` の実装の中心となっています。

## Interfaces and other types
### インターフェイス

Goのインターフェイスは、オブジェクトの動作を指定する方法を提供します。つまり、何かができるのであれば、それをここで使用することができます。カスタムプリンタは `String` メソッドで実装できますし、`Fprintf` は `Write` メソッドであらゆるものに出力を生成できます。

 1つまたは2つのメソッドしかないインターフェイスは、Goのコードではよく見られます。例えば、`Write`を実装しているものには`io.Writer`のように。通常、メソッドから派生した名前が付けられます。

1つの型が複数のインターフェースを実装することも可能です。例えば、コレクションは `sort.Interface` を実装していれば、`sort` パッケージのルーチンによってソートすることができます。このルーチンには `Len()`, `Less(i, j int) bool`, `Swap(i, j int)` が含まれており、また、カスタムのフォーマッタを持つこともできます。この例では、 `Sequence` がその両方を満たしています。

```go
type Sequence []int

// sort.Interfaceで必要なメソッドです。
func (s Sequence) Len() int {
    return len(s)
}
func (s Sequence) Less(i, j int) bool {
    return s[i] < s[j]
}
func (s Sequence) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}

// Copyは、Sequenceのコピーを返します。
func (s Sequence) Copy() Sequence {
    copy := make(Sequence, 0, len(s))
    return append(copy, s...)
}

// 印刷のためのメソッド - 印刷前に要素をソートします。
func (s Sequence) String() string {
    s = s.Copy() // コピーをして、引数を上書きしないようにしましょう。
    sort.Sort(s)
    str := "["
    for i, elem := range s { // Loop is O(N²); will fix that in next example.
        if i > 0 {
            str += " "
        }
        str += fmt.Sprint(elem)
    }
    return str + "]"
}
```

### 変換について

Sequence` の `String` メソッドは，`Sprint` がすでにスライスに対して行っている作業を再現しています．(また，複雑さは O(N^2) で，これは貧弱です)．`Sprint` を呼び出す前に `Sequence` をプレーンな `[]int` に変換すれば，この作業を分担することができます（また，高速化することもできます）．

```go
func (s Sequence) String() string {
    s = s.Copy()
    sort.Sort(s)
    return fmt.Sprint([]int(s))
}
```

このメソッドは、`String`メソッドから`Sprintf`を安全に呼び出すための変換テクニックのもう一つの例です。2つの型（`Sequence`と`[]int`）は型名を無視すれば同じものなので、それらの間で変換することは合法です。この変換は新しい値を生成するのではなく，一時的に既存の値が新しい型を持っているかのように振る舞うだけです。(整数から浮動小数点への変換のように、新しい値を作る合法的な変換は他にもあります)

Goプログラムでは、式の型を変換して別のメソッド群にアクセスすることが慣用的に行われています。例として、既存の型 `sort.IntSlice` を使って、例題全体を次のように減らすことができます。


```go
type Sequence []int

// 印刷のためのメソッド - 印刷前に要素をソートする
func (s Sequence) String() string {
    s = s.Copy()
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
```

ここでは、`Sequence`に複数のインターフェース（ソートと印刷）を実装させるのではなく、データアイテムを複数の型（`Sequence`、`sort.IntSlice`、`[]int`）に変換できる機能を利用して、それぞれが仕事の一部を行うようにしています。これは実際にはもっと珍しいことですが、効果的です。


### インターフェース変換と型アサーション

[タイプスイッチ](https://golang.org/doc/effective_go#type_switch)は変換の一種です。インターフェイスを受け取り、switch内の各caseについて、ある意味でそのcaseの型に変換します。ここでは，`fmt.Printf`のコードがタイプスイッチを使って値を文字列に変換する様子を簡略化して説明します．すでに文字列であれば、インターフェイスが保持する実際の文字列の値が必要となり、`String`メソッドがあれば、そのメソッドを呼び出した結果が必要となります。

```go
type Stringer interface {
    String() string
}

var value interface{} // Value provided by caller.
switch str := value.(type) {
case string:
    return str
case Stringer:
    return str.String()
}
```

最初のcaseは具体的な値を見つけ、2番目のcaseはインターフェイスを別のインターフェイスに変換します。このように型を混在させることは全く問題ありません。

しかし，気になる型が1つしかない場合はどうでしょうか？値が「文字列」を保持していることがわかっていて、それを取り出したいだけだったら？このような場合には、ワンケースのタイプスイッチで対応できますが、型アサーションでも対応できます。型アサーションはインターフェイスの値を受け取り、そこから指定された明示的な型の値を抽出します。構文は型スイッチを開く節を参考にしていますが、`type`キーワードではなく明示的な型を使用しています。

```go
value.(typeName)
```

と入力すると、結果として静的な型`typeName`を持つ新しい値が得られます。この型は，インターフェイスが持つ具象型か，値が変換できる第2のインターフェイス型でなければなりません．値の中にあるとわかっている文字列を取り出すには、次のように書きます。

```go
str := value.(string)
```

しかし、値に文字列が含まれていないことが判明した場合、プログラムはランタイムエラーでクラッシュします。これを防ぐために、"comma, ok "というイディオムを使って、値が文字列であるかどうかを安全にテストします： 

```go
str, ok := value.(string)
if ok {
    fmt.Printf("string value is: %q\n", str)
} else {
    fmt.Printf("value is not a string\n")
}
```

型の主張が失敗した場合、`str` は依然として存在し、文字列型となりますが、その値はゼロで、空の文字列となります。

この機能を説明するために、このセクションの最初に出てきたタイプスイッチと同等の `if`-`else` ステートメントを示します。

```go
if str, ok := value.(string); ok {
    return str
} else if str, ok := value.(Stringer); ok {
    return str.String()
}
```


### 一般性

ある型がインターフェイスを実装するためだけに存在し、そのインターフェイスを超えてエクスポートされたメソッドを持つことがない場合、その型自体をエクスポートする必要はありません。インターフェイスだけをエクスポートすることで、その値がインターフェイスに記述されている以上の興味深い動作を持たないことが明確になります。また、共通のメソッドのインスタンスごとにドキュメントを繰り返す必要もありません。

このような場合、コンストラクタは実装型ではなくインターフェイスの値を返すべきです。例えば，ハッシュライブラリでは，`crc32.NewIEEE`と`adler32.New`の両方がインタフェース型である`hash.Hash32`を返します．GoプログラムでCRC-32アルゴリズムをAdler-32に置き換えるには、コンストラクタの呼び出しを変更するだけで、残りのコードはアルゴリズムの変更による影響を受けません。

同様のアプローチにより、さまざまな `crypto` パッケージのストリーミング暗号アルゴリズムを、それらが連鎖するブロック暗号から分離することができます。crypto/cipher`パッケージの`Block`インターフェースは、ブロック暗号の動作を指定するもので、1つのデータブロックの暗号化を行います。また、`bufio`パッケージと同様に、このインタフェースを実装した暗号パッケージは、ブロック暗号の詳細を知らなくても、`Stream`インタフェースで表されるストリーミング暗号を構築することができます。

crypto/cipher`インターフェースは以下のようになります。

```go
type Block interface {
    BlockSize() int
    Encrypt(dst, src []byte)
    Decrypt(dst, src []byte)
}

type Stream interface {
    XORKeyStream(dst, src []byte)
}
```

カウンターモード（CTR）ストリームの定義は、ブロック暗号をストリーミング暗号に変えるもので、ブロック暗号の詳細は抽象化されていることに注意してください。


```go
// NewCTRは、指定されたBlockをカウンターモードで使用して暗号化/復号化を行うStreamを
// 返します。ivの長さは、Blockのブロックサイズと同じでなければなりません。
func NewCTR(block Block, iv []byte) Stream
```

`NewCTR`は、ある特定の暗号化アルゴリズムやデータソースだけでなく、`Block`インターフェースのあらゆる実装や、あらゆる`Stream`にも適用されます。インターフェイスの値を返すので、CTRの暗号化を他の暗号化モードに置き換えることは、局所的な変更になります。コンストラクタの呼び出しを編集する必要がありますが、周囲のコードは結果を `Stream` としてのみ扱わなければならないので、その違いに気づくことはありません。



### インターフェイスとメソッド

ほとんどのものにメソッドを付けることができるので、ほとんどのものがインターフェイスを満たすことができます。例えば、`http`パッケージには`Handler`というインタフェースが定義されています。`Handler`を実装したオブジェクトはHTTPリクエストに対応できます。

```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

`ResponseWriter`はそれ自体がインターフェイスで、クライアントにレスポンスを返すために必要なメソッドへのアクセスを提供します。これらのメソッドには標準の `Write` メソッドが含まれているので、 `io.Writer` が使える場所であれば `http.ResponseWriter` を使うことができます。`Request`は、クライアントからのリクエストを解析した表現を含む構造体です。

簡潔にするために、POSTを無視して、HTTPリクエストは常にGETであると仮定します。この単純化は、ハンドラの設定方法には影響しません。ここでは、ページの訪問回数をカウントするハンドラの簡単な実装を紹介します。

```go
// Simple counter server.
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
```

(テーマに沿って、`Fprintf` が `http.ResponseWriter` に出力できることに注目してください。) 実際のサーバでは、`ctr.n` へのアクセスは、同時アクセスから保護する必要があります。提案としては，`sync`と`atomic`のパッケージを参照してください．

参考までに，このようなサーバをURLツリーのノードにアタッチする方法を示します．

```go
import "net/http"
...
ctr := new(Counter)
http.Handle("/counter", ctr)
```

しかし、なぜ `Counter` を構造体にするのでしょうか？必要なのは整数だけです。(レシーバはポインタである必要があるので、インクリメントは呼び出し側から見えるようになっています)。

```go
// Simpler counter server.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    *ctr++
    fmt.Fprintf(w, "counter = %d\n", *ctr)
}
```

もしあなたのプログラムに、あるページが訪問されたことを通知する必要のある内部状態があるとしたらどうでしょう？チャネルをWebページに結びつけます。

```go
// 訪問のたびに通知を送るチャネルです。(おそらく、
// チャネルをバッファリングしたいのでしょう。)
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ch <- req
    fmt.Fprint(w, "notification sent")
}
```

最後に、`/args`にサーバーバイナリの起動時に使用した引数を表示したいとします。引数を表示する関数を書くのは簡単です。

```go
func ArgServer() {
    fmt.Println(os.Args)
}
```

これをHTTPサーバにするにはどうしたらいいでしょうか？`ArgServer`を、値を無視する何らかの型のメソッドにすることもできますが、もっと簡単な方法があります。ポインタやインタフェースを除くあらゆる型に対してメソッドを定義できるので、関数に対してメソッドを書くことができます。`http`パッケージにはこのようなコードが含まれています。

```go
// HandlerFunc型は、通常の関数をHTTPハンドラーとして使用できるようにするための
// アダプタです。 fが適切なシグネチャを持つ関数の場合、HandlerFunc(f)はfを
// 呼び出すHandlerオブジェクトです。
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
    f(w, req)
}
```

`HandlerFunc` is a type with a method, `ServeHTTP`, so values of that type can serve HTTP requests. Look at the implementation of the method: the receiver is a function, `f`, and the method calls `f`. That may seem odd but it's not that different from, say, the receiver being a channel and the method sending on the channel.

To make `ArgServer` into an HTTP server, we first modify it to have the right signature.

```go
// Argument server.
func ArgServer(w http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(w, os.Args)
}
```

`ArgServer` now has same signature as `HandlerFunc`, so it can be converted to that type to access its methods, just as we converted `Sequence` to `IntSlice` to access `IntSlice.Sort`. The code to set it up is concise:

```go
http.Handle("/args", http.HandlerFunc(ArgServer))
```

When someone visits the page `/args`, the handler installed at that page has value `ArgServer` and type `HandlerFunc`. The HTTP server will invoke the method `ServeHTTP` of that type, with `ArgServer` as the receiver, which will in turn call `ArgServer` (via the invocation `f(w, req)` inside `HandlerFunc.ServeHTTP`). The arguments will then be displayed.

In this section we have made an HTTP server from a struct, an integer, a channel, and a function, all because interfaces are just sets of methods, which can be defined for (almost) any type.


## The blank identifier

We've mentioned the blank identifier a couple of times now, in the context of [`for` `range` `loops`](https://golang.org/doc/effective_go#for) and [maps](https://golang.org/doc/effective_go#maps). The blank identifier can be assigned or declared with any value of any type, with the value discarded harmlessly. It's a bit like writing to the Unix `/dev/null` file: it represents a write-only value to be used as a place-holder where a variable is needed but the actual value is irrelevant. It has uses beyond those we've seen already.

### The blank identifier in multiple assignment

The use of a blank identifier in a `for` `range` loop is a special case of a general situation: multiple assignment.

If an assignment requires multiple values on the left side, but one of the values will not be used by the program, a blank identifier on the left-hand-side of the assignment avoids the need to create a dummy variable and makes it clear that the value is to be discarded. For instance, when calling a function that returns a value and an error, but only the error is important, use the blank identifier to discard the irrelevant value.

```go
if _, err := os.Stat(path); os.IsNotExist(err) {
	fmt.Printf("%s does not exist\n", path)
}
```

Occasionally you'll see code that discards the error value in order to ignore the error; this is terrible practice. Always check error returns; they're provided for a reason.

```go
// Bad! This code will crash if path does not exist.
fi, _ := os.Stat(path)
if fi.IsDir() {
    fmt.Printf("%s is a directory\n", path)
}
```


### Unused imports and variables

It is an error to import a package or to declare a variable without using it. Unused imports bloat the program and slow compilation, while a variable that is initialized but not used is at least a wasted computation and perhaps indicative of a larger bug. When a program is under active development, however, unused imports and variables often arise and it can be annoying to delete them just to have the compilation proceed, only to have them be needed again later. The blank identifier provides a workaround.

This half-written program has two unused imports (`fmt` and `io`) and an unused variable (`fd`), so it will not compile, but it would be nice to see if the code so far is correct.

```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: use fd.
}
```

To silence complaints about the unused imports, use a blank identifier to refer to a symbol from the imported package. Similarly, assigning the unused variable `fd` to the blank identifier will silence the unused variable error. This version of the program does compile.

```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

var _ = fmt.Printf // For debugging; delete when done.
var _ io.Reader    // For debugging; delete when done.

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: use fd.
    _ = fd
}
```

By convention, the global declarations to silence import errors should come right after the imports and be commented, both to make them easy to find and as a reminder to clean things up later.


### Import for side effect

An unused import like `fmt` or `io` in the previous example should eventually be used or removed: blank assignments identify code as a work in progress. But sometimes it is useful to import a package only for its side effects, without any explicit use. For example, during its `init` function, the [`net/http/pprof`](https://golang.org/pkg/net/http/pprof/) package registers HTTP handlers that provide debugging information. It has an exported API, but most clients need only the handler registration and access the data through a web page. To import the package only for its side effects, rename the package to the blank identifier:

```go
import _ "net/http/pprof"
```

This form of import makes clear that the package is being imported for its side effects, because there is no other possible use of the package: in this file, it doesn't have a name. (If it did, and we didn't use that name, the compiler would reject the program.)


### Interface checks

As we saw in the discussion of [interfaces](https://golang.org/doc/effective_go#interfaces_and_types) above, a type need not declare explicitly that it implements an interface. Instead, a type implements the interface just by implementing the interface's methods. In practice, most interface conversions are static and therefore checked at compile time. For example, passing an `*os.File` to a function expecting an `io.Reader` will not compile unless `*os.File` implements the `io.Reader` interface.

Some interface checks do happen at run-time, though. One instance is in the [`encoding/json`](https://golang.org/pkg/encoding/json/) package, which defines a [`Marshaler`](https://golang.org/pkg/encoding/json/#Marshaler) interface. When the JSON encoder receives a value that implements that interface, the encoder invokes the value's marshaling method to convert it to JSON instead of doing the standard conversion. The encoder checks this property at run time with a [type assertion](https://golang.org/doc/effective_go#interface_conversions) like:

```go
m, ok := val.(json.Marshaler)
```

If it's necessary only to ask whether a type implements an interface, without actually using the interface itself, perhaps as part of an error check, use the blank identifier to ignore the type-asserted value:

```go
if _, ok := val.(json.Marshaler); ok {
    fmt.Printf("value %v of type %T implements json.Marshaler\n", val, val)
}
```

One place this situation arises is when it is necessary to guarantee within the package implementing the type that it actually satisfies the interface. If a type — for example, [`json.RawMessage`](https://golang.org/pkg/encoding/json/#RawMessage) — needs a custom JSON representation, it should implement `json.Marshaler`, but there are no static conversions that would cause the compiler to verify this automatically. If the type inadvertently fails to satisfy the interface, the JSON encoder will still work, but will not use the custom implementation. To guarantee that the implementation is correct, a global declaration using the blank identifier can be used in the package:

```go
var _ json.Marshaler = (*RawMessage)(nil)
```

In this declaration, the assignment involving a conversion of a `*RawMessage` to a `Marshaler` requires that `*RawMessage` implements `Marshaler`, and that property will be checked at compile time. Should the `json.Marshaler` interface change, this package will no longer compile and we will be on notice that it needs to be updated.

The appearance of the blank identifier in this construct indicates that the declaration exists only for the type checking, not to create a variable. Don't do this for every type that satisfies an interface, though. By convention, such declarations are only used when there are no static conversions already present in the code, which is a rare event.


## Embedding

Go does not provide the typical, type-driven notion of subclassing, but it does have the ability to “borrow” pieces of an implementation by embedding types within a struct or interface.

Interface embedding is very simple. We've mentioned the `io.Reader` and `io.Writer` interfaces before; here are their definitions.

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
```

The `io` package also exports several other interfaces that specify objects that can implement several such methods. For instance, there is `io.ReadWriter`, an interface containing both `Read` and `Write`. We could specify `io.ReadWriter` by listing the two methods explicitly, but it's easier and more evocative to embed the two interfaces to form the new one, like this:

```go
// ReadWriter is the interface that combines the Reader and Writer interfaces.
type ReadWriter interface {
    Reader
    Writer
}
```

This says just what it looks like: A `ReadWriter` can do what a `Reader` does and what a `Writer` does; it is a union of the embedded interfaces. Only interfaces can be embedded within interfaces.

The same basic idea applies to structs, but with more far-reaching implications. The `bufio` package has two struct types, `bufio.Reader` and `bufio.Writer`, each of which of course implements the analogous interfaces from package `io`. And `bufio` also implements a buffered reader/writer, which it does by combining a reader and a writer into one struct using embedding: it lists the types within the struct but does not give them field names.

```go
// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
    *Reader  // *bufio.Reader
    *Writer  // *bufio.Writer
}
```

The embedded elements are pointers to structs and of course must be initialized to point to valid structs before they can be used. The `ReadWriter` struct could be written as

```go
type ReadWriter struct {
    reader *Reader
    writer *Writer
}
```

but then to promote the methods of the fields and to satisfy the `io` interfaces, we would also need to provide forwarding methods, like this:

```go
func (rw *ReadWriter) Read(p []byte) (n int, err error) {
    return rw.reader.Read(p)
}
```

By embedding the structs directly, we avoid this bookkeeping. The methods of embedded types come along for free, which means that `bufio.ReadWriter` not only has the methods of `bufio.Reader` and `bufio.Writer`, it also satisfies all three interfaces: `io.Reader`, `io.Writer`, and `io.ReadWriter`.

There's an important way in which embedding differs from subclassing. When we embed a type, the methods of that type become methods of the outer type, but when they are invoked the receiver of the method is the inner type, not the outer one. In our example, when the `Read` method of a `bufio.ReadWriter` is invoked, it has exactly the same effect as the forwarding method written out above; the receiver is the `reader` field of the `ReadWriter`, not the `ReadWriter` itself.

Embedding can also be a simple convenience. This example shows an embedded field alongside a regular, named field.

```go
type Job struct {
    Command string
    *log.Logger
}
```

The `Job` type now has the `Print`, `Printf`, `Println` and other methods of `*log.Logger`. We could have given the `Logger` a field name, of course, but it's not necessary to do so. And now, once initialized, we can log to the `Job`:


```go
job.Println("starting now...")
```

The `Logger` is a regular field of the `Job` struct, so we can initialize it in the usual way inside the constructor for `Job`, like this,

```go
func NewJob(command string, logger *log.Logger) *Job {
    return &Job{command, logger}
}
```

or with a composite literal,

```go
job := &Job{command, log.New(os.Stderr, "Job: ", log.Ldate)}
```

If we need to refer to an embedded field directly, the type name of the field, ignoring the package qualifier, serves as a field name, as it did in the `Read` method of our `ReadWriter` struct. Here, if we needed to access the `*log.Logger` of a `Job` variable `job`, we would write `job.Logger`, which would be useful if we wanted to refine the methods of `Logger`.

```go
func (job *Job) Printf(format string, args ...interface{}) {
    job.Logger.Printf("%q: %s", job.Command, fmt.Sprintf(format, args...))
}
```

Embedding types introduces the problem of name conflicts but the rules to resolve them are simple. First, a field or method `X` hides any other item `X` in a more deeply nested part of the type. If `log.Logger` contained a field or method called `Command`, the `Command` field of `Job` would dominate it.

Second, if the same name appears at the same nesting level, it is usually an error; it would be erroneous to embed `log.Logger` if the `Job` struct contained another field or method called `Logger`. However, if the duplicate name is never mentioned in the program outside the type definition, it is OK. This qualification provides some protection against changes made to types embedded from outside; there is no problem if a field is added that conflicts with another field in another subtype if neither field is ever used.


## Concurrency
### Share by communicating

Concurrent programming is a large topic and there is space only for some Go-specific highlights here.

Concurrent programming in many environments is made difficult by the subtleties required to implement correct access to shared variables. Go encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution. Only one goroutine has access to the value at any given time. Data races cannot occur, by design. To encourage this way of thinking we have reduced it to a slogan:

    Do not communicate by sharing memory; instead, share memory by communicating.

This approach can be taken too far. Reference counts may be best done by putting a mutex around an integer variable, for instance. But as a high-level approach, using channels to control access makes it easier to write clear, correct programs.

One way to think about this model is to consider a typical single-threaded program running on one CPU. It has no need for synchronization primitives. Now run another such instance; it too needs no synchronization. Now let those two communicate; if the communication is the synchronizer, there's still no need for other synchronization. Unix pipelines, for example, fit this model perfectly. Although Go's approach to concurrency originates in Hoare's Communicating Sequential Processes (CSP), it can also be seen as a type-safe generalization of Unix pipes.



### Goroutines

They're called goroutines because the existing terms—threads, coroutines, processes, and so on—convey inaccurate connotations. A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required.

Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run. Their design hides many of the complexities of thread creation and management.

Prefix a function or method call with the `go` keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently. (The effect is similar to the Unix shell's `&` notation for running a command in the background.)

```go
go list.Sort()  // run list.Sort concurrently; don't wait for it.
```

A function literal can be handy in a goroutine invocation.

```go
func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // Note the parentheses - must call the function.
}
```

In Go, function literals are closures: the implementation makes sure the variables referred to by the function survive as long as they are active.

These examples aren't too practical because the functions have no way of signaling completion. For that, we need channels.


### Channels

Like maps, channels are allocated with `make`, and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size for the channel. The default is zero, for an unbuffered or synchronous channel.

```go
ci := make(chan int)            // unbuffered channel of integers
cj := make(chan int, 0)         // unbuffered channel of integers
cs := make(chan *os.File, 100)  // buffered channel of pointers to Files
```

Unbuffered channels combine communication—the exchange of a value—with synchronization—guaranteeing that two calculations (goroutines) are in a known state.

There are lots of nice idioms using channels. Here's one to get us started. In the previous section we launched a sort in the background. A channel can allow the launching goroutine to wait for the sort to complete.

```go
c := make(chan int)  // Allocate a channel.
// Start the sort in a goroutine; when it completes, signal on the channel.
go func() {
    list.Sort()
    c <- 1  // Send a signal; value does not matter.
}()
doSomethingForAWhile()
<-c   // Wait for sort to finish; discard sent value.
```

Receivers always block until there is data to receive. If the channel is unbuffered, the sender blocks until the receiver has received the value. If the channel has a buffer, the sender blocks only until the value has been copied to the buffer; if the buffer is full, this means waiting until some receiver has retrieved a value.

A buffered channel can be used like a semaphore, for instance to limit throughput. In this example, incoming requests are passed to `handle`, which sends a value into the channel, processes the request, and then receives a value from the channel to ready the “semaphore” for the next consumer. The capacity of the channel buffer limits the number of simultaneous calls to `process`.

```go
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem <- 1    // Wait for active queue to drain.
    process(r)  // May take a long time.
    <-sem       // Done; enable next request to run.
}

func Serve(queue chan *Request) {
    for {
        req := <-queue
        go handle(req)  // Don't wait for handle to finish.
    }
}
```

Once `MaxOutstanding` handlers are executing `process`, any more will block trying to send into the filled channel buffer, until one of the existing handlers finishes and receives from the buffer.

This design has a problem, though: `Serve` creates a new goroutine for every incoming request, even though only `MaxOutstanding` of them can run at any moment. As a result, the program can consume unlimited resources if the requests come in too fast. We can address that deficiency by changing `Serve` to gate the creation of the goroutines. Here's an obvious solution, but beware it has a bug we'll fix subsequently:

```go
func Serve(queue chan *Request) {
    for req := range queue {
        sem <- 1
        go func() {
            process(req) // Buggy; see explanation below.
            <-sem
        }()
    }
}
```

The bug is that in a Go `for` loop, the loop variable is reused for each iteration, so the `req` variable is shared across all goroutines. That's not what we want. We need to make sure that `req` is unique for each goroutine. Here's one way to do that, passing the value of `req` as an argument to the closure in the goroutine:

```go
func Serve(queue chan *Request) {
    for req := range queue {
        sem <- 1
        go func(req *Request) {
            process(req)
            <-sem
        }(req)
    }
}
```

Compare this version with the previous to see the difference in how the closure is declared and run. Another solution is just to create a new variable with the same name, as in this example:

```go
func Serve(queue chan *Request) {
    for req := range queue {
        req := req // Create new instance of req for the goroutine.
        sem <- 1
        go func() {
            process(req)
            <-sem
        }()
    }
}
```

It may seem odd to write

```go
req := req
```

but it's legal and idiomatic in Go to do this. You get a fresh version of the variable with the same name, deliberately shadowing the loop variable locally but unique to each goroutine.

Going back to the general problem of writing the server, another approach that manages resources well is to start a fixed number of `handle` goroutines all reading from the request channel. The number of goroutines limits the number of simultaneous calls to `process`. This `Serve` function also accepts a channel on which it will be told to exit; after launching the goroutines it blocks receiving from that channel.

```go
func handle(queue chan *Request) {
    for r := range queue {
        process(r)
    }
}

func Serve(clientRequests chan *Request, quit chan bool) {
    // Start handlers
    for i := 0; i < MaxOutstanding; i++ {
        go handle(clientRequests)
    }
    <-quit  // Wait to be told to exit.
}
```

### Channels of channels

One of the most important properties of Go is that a channel is a first-class value that can be allocated and passed around like any other. A common use of this property is to implement safe, parallel demultiplexing.

In the example in the previous section, `handle` was an idealized handler for a request but we didn't define the type it was handling. If that type includes a channel on which to reply, each client can provide its own path for the answer. Here's a schematic definition of type `Request`.

```go
type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
```

The client provides a function and its arguments, as well as a channel inside the request object on which to receive the answer.

```go
func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests <- request
// Wait for response.
fmt.Printf("answer: %d\n", <-request.resultChan)
```

On the server side, the handler function is the only thing that changes.

```go
func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan <- req.f(req.args)
    }
}
```

There's clearly a lot more to do to make it realistic, but this code is a framework for a rate-limited, parallel, non-blocking RPC system, and there's not a mutex in sight.


### Parallelization

Another application of these ideas is to parallelize a calculation across multiple CPU cores. If the calculation can be broken into separate pieces that can execute independently, it can be parallelized, with a channel to signal when each piece completes.

Let's say we have an expensive operation to perform on a vector of items, and that the value of the operation on each item is independent, as in this idealized example.

```go
type Vector []float64

// Apply the operation to v[i], v[i+1] ... up to v[n-1].
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i < n; i++ {
        v[i] += u.Op(v[i])
    }
    c <- 1    // signal that this piece is done
}
```

We launch the pieces independently in a loop, one per CPU. They can complete in any order but it doesn't matter; we just count the completion signals by draining the channel after launching all the goroutines.

```go
const numCPU = 4 // number of CPU cores

func (v Vector) DoAll(u Vector) {
    c := make(chan int, numCPU)  // Buffering optional but sensible.
    for i := 0; i < numCPU; i++ {
        go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c)
    }
    // Drain the channel.
    for i := 0; i < numCPU; i++ {
        <-c    // wait for one task to complete
    }
    // All done.
}
```

Rather than create a constant value for numCPU, we can ask the runtime what value is appropriate. The function [`runtime.NumCPU`](https://golang.org/pkg/runtime#NumCPU) returns the number of hardware CPU cores in the machine, so we could write

```go
var numCPU = runtime.NumCPU()
```

There is also a function [`runtime.GOMAXPROCS`](https://golang.org/pkg/runtime#GOMAXPROCS), which reports (or sets) the user-specified number of cores that a Go program can have running simultaneously. It defaults to the value of `runtime.NumCPU` but can be overridden by setting the similarly named shell environment variable or by calling the function with a positive number. Calling it with zero just queries the value. Therefore if we want to honor the user's resource request, we should write

```go
var numCPU = runtime.GOMAXPROCS(0)
```

Be sure not to confuse the ideas of concurrency—structuring a program as independently executing components—and parallelism—executing calculations in parallel for efficiency on multiple CPUs. Although the concurrency features of Go can make some problems easy to structure as parallel computations, Go is a concurrent language, not a parallel one, and not all parallelization problems fit Go's model. For a discussion of the distinction, see the talk cited in [this blog post](https://blog.golang.org/2013/01/concurrency-is-not-parallelism.html).



### A leaky buffer

The tools of concurrent programming can even make non-concurrent ideas easier to express. Here's an example abstracted from an RPC package. The client goroutine loops receiving data from some source, perhaps a network. To avoid allocating and freeing buffers, it keeps a free list, and uses a buffered channel to represent it. If the channel is empty, a new buffer gets allocated. Once the message buffer is ready, it's sent to the server on `serverChan`.

```go
var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
    for {
        var b *Buffer
        // Grab a buffer if available; allocate if not.
        select {
        case b = <-freeList:
            // Got one; nothing more to do.
        default:
            // None free, so allocate a new one.
            b = new(Buffer)
        }
        load(b)              // Read next message from the net.
        serverChan <- b      // Send to server.
    }
}
```

The server loop receives each message from the client, processes it, and returns the buffer to the free list.


```go
func server() {
    for {
        b := <-serverChan    // Wait for work.
        process(b)
        // Reuse buffer if there's room.
        select {
        case freeList <- b:
            // Buffer on free list; nothing more to do.
        default:
            // Free list full, just carry on.
        }
    }
}
```

The client attempts to retrieve a buffer from `freeList`; if none is available, it allocates a fresh one. The server's send to `freeList` puts `b` back on the free list unless the list is full, in which case the buffer is dropped on the floor to be reclaimed by the garbage collector. (The `default` clauses in the `select` statements execute when no other case is ready, meaning that the `selects` never block.) This implementation builds a leaky bucket free list in just a few lines, relying on the buffered channel and the garbage collector for bookkeeping.


## Errors

Library routines must often return some sort of error indication to the caller. As mentioned earlier, Go's multivalue return makes it easy to return a detailed error description alongside the normal return value. It is good style to use this feature to provide detailed error information. For example, as we'll see, `os.Open` doesn't just return a `nil` pointer on failure, it also returns an error value that describes what went wrong.

By convention, errors have type `error`, a simple built-in interface.

```go
type error interface {
    Error() string
}
```

A library writer is free to implement this interface with a richer model under the covers, making it possible not only to see the error but also to provide some context. As mentioned, alongside the usual `*os.File` return value, `os.Open` also returns an error value. If the file is opened successfully, the error will be `nil`, but when there is a problem, it will hold an `os.PathError`:

```go
// PathError records an error and the operation and
// file path that caused it.
type PathError struct {
    Op string    // "open", "unlink", etc.
    Path string  // The associated file.
    Err error    // Returned by the system call.
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
```

PathError's Error generates a string like this:

```sh
open /etc/passwx: no such file or directory
```

Such an error, which includes the problematic file name, the operation, and the operating system error it triggered, is useful even if printed far from the call that caused it; it is much more informative than the plain "no such file or directory".

When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error. For example, in package `image`, the string representation for a decoding error due to an unknown format is "image: unknown format".

Callers that care about the precise error details can use a type switch or a type assertion to look for specific errors and extract details. For `PathErrors` this might include examining the internal `Err` field for recoverable failures.

```go
for try := 0; try < 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
```

The second `if` statement here is another [type assertion](https://golang.org/doc/effective_go#interface_conversions). If it fails, `ok` will be `false`, and `e` will be `nil`. If it succeeds, `ok` will be `true`, which means the error was of type `*os.PathError`, and then so is `e`, which we can examine for more information about the error.


### Panic

The usual way to report an error to a caller is to return an `error` as an extra return value. The canonical `Read` method is a well-known instance; it returns a byte count and an `error`. But what if the error is unrecoverable? Sometimes the program simply cannot continue.

For this purpose, there is a built-in function `panic` that in effect creates a run-time error that will stop the program (but see the next section). The function takes a single argument of arbitrary type — often a string — to be printed as the program dies. It's also a way to indicate that something impossible has happened, such as exiting an infinite loop.

```go
// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i < 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
```

This is only an example but real library functions should avoid `panic`. If the problem can be masked or worked around, it's always better to let things continue to run rather than taking down the whole program. One possible counterexample is during initialization: if the library truly cannot set itself up, it might be reasonable to panic, so to speak.


```go
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
```


### Recover

When `panic` is called, including implicitly for run-time errors such as indexing a slice out of bounds or failing a type assertion, it immediately stops execution of the current function and begins unwinding the stack of the goroutine, running any deferred functions along the way. If that unwinding reaches the top of the goroutine's stack, the program dies. However, it is possible to use the built-in function `recover` to regain control of the goroutine and resume normal execution.

A call to `recover` stops the unwinding and returns the argument passed to `panic`. Because the only code that runs while unwinding is inside deferred functions, `recover` is only useful inside deferred functions.

One application of `recover` is to shut down a failing goroutine inside a server without killing the other executing goroutines.

```go
func server(workChan <-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
```

In this example, if `do(work)` panics, the result will be logged and the goroutine will exit cleanly without disturbing the others. There's no need to do anything else in the deferred closure; calling `recover` handles the condition completely.

Because `recover` always returns `nil` unless called directly from a deferred function, deferred code can call library routines that themselves use `panic` and `recover` without failing. As an example, the deferred function in `safelyDo` might call a logging function before calling `recover`, and that logging code would run unaffected by the panicking state.

With our recovery pattern in place, the `do` function (and anything it calls) can get out of any bad situation cleanly by calling `panic`. We can use that idea to simplify error handling in complex software. Let's look at an idealized version of a `regexp` package, which reports parsing errors by calling `panic` with a local error type. Here's the definition of `Error`, an `error` method, and the `Compile` function.


```go
// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}
```

If `doParse` panics, the recovery block will set the return value to `nil` — deferred functions can modify named return values. It will then check, in the assignment to `err`, that the problem was a parse error by asserting that it has the local type `Error`. If it does not, the type assertion will fail, causing a run-time error that continues the stack unwinding as though nothing had interrupted it. This check means that if something unexpected happens, such as an index out of bounds, the code will fail even though we are using `panic` and `recover` to handle parse errors.

With error handling in place, the `error` method (because it's a method bound to a type, it's fine, even natural, for it to have the same name as the builtin `error` type) makes it easy to report parse errors without worrying about unwinding the parse stack by hand:


```go
if pos == 0 {
    re.error("'*' illegal at start of expression")
}
```

Useful though this pattern is, it should be used only within a package. `Parse` turns its internal `panic` calls into `error` values; it does not expose `panics` to its client. That is a good rule to follow.

By the way, this re-panic idiom changes the panic value if an actual error occurs. However, both the original and new failures will be presented in the crash report, so the root cause of the problem will still be visible. Thus this simple re-panic approach is usually sufficient—it's a crash after all—but if you want to display only the original value, you can write a little more code to filter unexpected problems and re-panic with the original error. That's left as an exercise for the reader.

## A web server

Let's finish with a complete Go program, a web server. This one is actually a kind of web re-server. Google provides a service at chart.apis.google.com that does automatic formatting of data into charts and graphs. It's hard to use interactively, though, because you need to put the data into the URL as a query. The program here provides a nicer interface to one form of data: given a short piece of text, it calls on the chart server to produce a QR code, a matrix of boxes that encode the text. That image can be grabbed with your cell phone's camera and interpreted as, for instance, a URL, saving you typing the URL into the phone's tiny keyboard.

Here's the complete program. An explanation follows.

```go
package main

import (
    "flag"
    "html/template"
    "log"
    "net/http"
)

var addr = flag.String("addr", ":1718", "http service address") // Q=17, R=18

var templ = template.Must(template.New("qr").Parse(templateStr))

func main() {
    flag.Parse()
    http.Handle("/", http.HandlerFunc(QR))
    err := http.ListenAndServe(*addr, nil)
    if err != nil {
        log.Fatal("ListenAndServe:", err)
    }
}

func QR(w http.ResponseWriter, req *http.Request) {
    templ.Execute(w, req.FormValue("s"))
}

const templateStr = `
<html>
<head>
<title>QR Link Generator</title>
</head>
<body>
{{if .}}
<img src="http://chart.apis.google.com/chart?chs=300x300&cht=qr&choe=UTF-8&chl={{.}}" />
<br>
{{.}}
<br>
<br>
{{end}}
<form action="/" name=f method="GET">
    <input maxLength=1024 size=70 name=s value="" title="Text to QR Encode">
    <input type=submit value="Show QR" name=qr>
</form>
</body>
</html>
`
```

The pieces up to main should be easy to follow. The one flag sets a default HTTP port for our server. The template variable templ is where the fun happens. It builds an HTML template that will be executed by the server to display the page; more about that in a moment.

The main function parses the flags and, using the mechanism we talked about above, binds the function QR to the root path for the server. Then http.ListenAndServe is called to start the server; it blocks while the server runs.

QR just receives the request, which contains form data, and executes the template on the data in the form value named s.

The template package html/template is powerful; this program just touches on its capabilities. In essence, it rewrites a piece of HTML text on the fly by substituting elements derived from data items passed to templ.Execute, in this case the form value. Within the template text (templateStr), double-brace-delimited pieces denote template actions. The piece from {{if .}} to {{end}} executes only if the value of the current data item, called . (dot), is non-empty. That is, when the string is empty, this piece of the template is suppressed.

The two snippets {{.}} say to show the data presented to the template—the query string—on the web page. The HTML template package automatically provides appropriate escaping so the text is safe to display.

The rest of the template string is just the HTML to show when the page loads. If this is too quick an explanation, see the [documentation](https://golang.org/pkg/html/template/) for the template package for a more thorough discussion.

And there you have it: a useful web server in a few lines of code plus some data-driven HTML text. Go is powerful enough to make a lot happen in a few lines.